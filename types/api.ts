/* tslint:disable */
/* eslint-disable */
/**
 * PostgREST API
 * This is a dynamic API generated by PostgREST
 *
 * The version of the OpenAPI document: 9.0.0.20220211 (pre-release) (dcf7ade)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Accounts
 */
export interface Accounts {
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'accountName'?: string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Accounts
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'commercial'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'taxExempt'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'taxID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'acquisitionDate': string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'leadSourceID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'billingAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'paymentTerm'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'doNotMail'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'doNotEmail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'billingLocation'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Accounts
     */
    'doNotCall'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'lastStatementDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'fax'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'phones'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Accounts
     */
    'phoneNumbersList'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'phoneNumbersSearch'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Accounts
     */
    'transcriptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'fts'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts
     */
    'addressText'?: string;
}
/**
 * recevied from cloud run or cloud function
 * @export
 * @interface CallTranscriptions
 */
export interface CallTranscriptions {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof CallTranscriptions
     */
    'id': string;
    /**
     * raw transcription
     * @type {string}
     * @memberof CallTranscriptions
     */
    'raw_transcription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'audio_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'caller'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'callee'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'partnerNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallTranscriptions
     */
    'datetime'?: string;
}
/**
 * 
 * @export
 * @interface DeviceEvents
 */
export interface DeviceEvents {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof DeviceEvents
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceEvents
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceEvents
     */
    'updatedAt': string;
    /**
     * Note: This is a Foreign Key to `devices.id`.<fk table=\'devices\' column=\'id\'/>
     * @type {string}
     * @memberof DeviceEvents
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceEvents
     */
    'locationData'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceEvents
     */
    'locationString'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceEvents
     */
    'clientTime'?: string;
}
/**
 * 
 * @export
 * @interface Devices
 */
export interface Devices {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Devices
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Devices
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Devices
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Employees
 */
export interface Employees {
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'firstName'?: string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Employees
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Employees
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Employees
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'employeename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'lastSeen'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'onsipId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'office'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employees
     */
    'bio'?: string;
}
/**
 * 
 * @export
 * @interface Followings
 */
export interface Followings {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Followings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Followings
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Followings
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Followings
     */
    'followingId'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Lineitems
 */
export interface Lineitems {
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'createdAt': string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Lineitems
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'workOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Lineitems
     */
    'rowIndex'?: number;
    /**
     * 
     * @type {number}
     * @memberof Lineitems
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'serviceDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'total'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Lineitems
     */
    'taxed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Lineitems
     */
    'upsale'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'itemName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'name'?: string;
    /**
     * Note: This is a Foreign Key to `orders.id`.<fk table=\'orders\' column=\'id\'/>
     * @type {string}
     * @memberof Lineitems
     */
    'orderId'?: string;
    /**
     * Note: This is a Foreign Key to `orderitems.id`.<fk table=\'orderitems\' column=\'id\'/>
     * @type {string}
     * @memberof Lineitems
     */
    'orderItemId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'lineItemStatus'?: LineitemsLineItemStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Lineitems
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Lineitems
     */
    'imageList'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Lineitems
     */
    'status'?: string;
}

export const LineitemsLineItemStatusEnum = {
    NotStarted: 'NotStarted',
    InProgress: 'InProgress',
    Passed: 'Passed',
    Failed: 'Failed',
    SetForDelivery: 'SetForDelivery',
    SetForPickup: 'SetForPickup',
    Completed: 'Completed'
} as const;

export type LineitemsLineItemStatusEnum = typeof LineitemsLineItemStatusEnum[keyof typeof LineitemsLineItemStatusEnum];

/**
 * 
 * @export
 * @interface Orderitems
 */
export interface Orderitems {
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'addToFavorites'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'commissionable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'itemGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'itemType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'price'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'priceLocked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Orderitems
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Orderitems
     */
    'rowNumber'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'taxed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Orderitems
     */
    'upsaleItem'?: boolean;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Orderitems
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Orderitems
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface Orders
 */
export interface Orders {
    /**
     * Note: This is a Foreign Key to `accounts.id`.<fk table=\'accounts\' column=\'id\'/>
     * @type {string}
     * @memberof Orders
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'accountName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Orders
     */
    'balanceDue'?: number;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'dateCompleted'?: string;
    /**
     * 
     * @type {number}
     * @memberof Orders
     */
    'discountPercent'?: number;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'dueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Orders
     */
    'grandTotal'?: number;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'image': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Orders
     */
    'imagesFullUrlList'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Orders
     */
    'imagesThumbUrlList'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'itemGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'merchantFeesTotal'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'note'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Orders
     */
    'notes'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Orders
     */
    'orderNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'orderStatus'?: OrdersOrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'orderType'?: OrdersOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'originalType'?: OrdersOriginalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'refNumber'?: string;
    /**
     * Note: This is a Foreign Key to `sites.id`.<fk table=\'sites\' column=\'id\'/>
     * @type {string}
     * @memberof Orders
     */
    'siteId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'subTotal'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'taxId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Orders
     */
    'taxRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'taxTotal'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'tipCollected'?: string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'updatedByName'?: string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Orders
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Orders
     */
    'workOrderType'?: string;
}

export const OrdersOrderStatusEnum = {
    NotStarted: 'NotStarted',
    InProgress: 'InProgress',
    WaitingForInspection: 'WaitingForInspection',
    Passed: 'Passed',
    Failed: 'Failed',
    SetForDelivery: 'SetForDelivery',
    SetForPickup: 'SetForPickup',
    Completed: 'Completed'
} as const;

export type OrdersOrderStatusEnum = typeof OrdersOrderStatusEnum[keyof typeof OrdersOrderStatusEnum];
export const OrdersOrderTypeEnum = {
    WorkOrder: 'WorkOrder',
    Invoice: 'Invoice',
    Estimate: 'Estimate',
    Voided: 'Voided',
    Void: 'Void'
} as const;

export type OrdersOrderTypeEnum = typeof OrdersOrderTypeEnum[keyof typeof OrdersOrderTypeEnum];
export const OrdersOriginalTypeEnum = {
    WorkOrder: 'WorkOrder',
    Invoice: 'Invoice',
    Estimate: 'Estimate',
    Voided: 'Voided',
    Void: 'Void'
} as const;

export type OrdersOriginalTypeEnum = typeof OrdersOriginalTypeEnum[keyof typeof OrdersOriginalTypeEnum];

/**
 * 
 * @export
 * @interface Products
 */
export interface Products {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Products
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Products
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'github_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'instagram'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Products
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Products
     */
    'supabase_features'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Products
     */
    'approved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Products
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface ProductsView
 */
export interface ProductsView {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof ProductsView
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductsView
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'github_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'instagram'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductsView
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductsView
     */
    'supabase_features'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductsView
     */
    'approved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductsView
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductsView
     */
    'views'?: number;
}
/**
 * 
 * @export
 * @interface Profiles
 */
export interface Profiles {
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'tfa_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'last_access'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'last_page'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'external_identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    'auth_data'?: string;
    /**
     * 
     * @type {number}
     * @memberof Profiles
     */
    'email_notifications'?: number;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Profiles
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RpcAnonymousGetVideoDetailPostRequest
 */
export interface RpcAnonymousGetVideoDetailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcAnonymousGetVideoDetailPostRequest
     */
    'video_id': string;
}
/**
 * 
 * @export
 * @interface RpcFollowersPostRequest
 */
export interface RpcFollowersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcFollowersPostRequest
     */
    'target_user_id': string;
    /**
     * 
     * @type {string}
     * @memberof RpcFollowersPostRequest
     */
    'my_user_id': string;
}
/**
 * 
 * @export
 * @interface RpcGetLastUpdatedPostRequest
 */
export interface RpcGetLastUpdatedPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcGetLastUpdatedPostRequest
     */
    'nameoftable': string;
}
/**
 * 
 * @export
 * @interface RpcGetSupabaseTagsPostRequest
 */
export interface RpcGetSupabaseTagsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcGetSupabaseTagsPostRequest
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface RpcGetVideoDetailPostRequest
 */
export interface RpcGetVideoDetailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcGetVideoDetailPostRequest
     */
    'video_id': string;
    /**
     * 
     * @type {string}
     * @memberof RpcGetVideoDetailPostRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface RpcNearbyVideosPostRequest
 */
export interface RpcNearbyVideosPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RpcNearbyVideosPostRequest
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof RpcNearbyVideosPostRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface RpcVideosInBoudingBoxPostRequest
 */
export interface RpcVideosInBoudingBoxPostRequest {
    /**
     * 
     * @type {number}
     * @memberof RpcVideosInBoudingBoxPostRequest
     */
    'max_lng': number;
    /**
     * 
     * @type {number}
     * @memberof RpcVideosInBoudingBoxPostRequest
     */
    'max_lat': number;
    /**
     * 
     * @type {number}
     * @memberof RpcVideosInBoudingBoxPostRequest
     */
    'min_lng': number;
    /**
     * 
     * @type {string}
     * @memberof RpcVideosInBoudingBoxPostRequest
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof RpcVideosInBoudingBoxPostRequest
     */
    'min_lat': number;
}
/**
 * 
 * @export
 * @interface Sdrs
 */
export interface Sdrs {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Sdrs
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'partnerNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'partnerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'staffMember'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'end'?: string;
    /**
     * 
     * @type {number}
     * @memberof Sdrs
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'direction'?: SdrsDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'disposition'?: SdrsDispositionEnum;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'createdAt'?: string;
    /**
     * Note: This is a Foreign Key to `employees.id`.<fk table=\'employees\' column=\'id\'/>
     * @type {string}
     * @memberof Sdrs
     */
    'userId'?: string;
    /**
     * Note: This is a Foreign Key to `accounts.id`.<fk table=\'accounts\' column=\'id\'/>
     * @type {string}
     * @memberof Sdrs
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sdrs
     */
    'transcription'?: string;
}

export const SdrsDirectionEnum = {
    In: 'In',
    Out: 'Out'
} as const;

export type SdrsDirectionEnum = typeof SdrsDirectionEnum[keyof typeof SdrsDirectionEnum];
export const SdrsDispositionEnum = {
    Answered: 'Answered',
    Cancelled: 'Cancelled',
    Failed: 'Failed',
    Rejected: 'Rejected',
    Expired: 'Expired',
    Unanswered: 'Unanswered'
} as const;

export type SdrsDispositionEnum = typeof SdrsDispositionEnum[keyof typeof SdrsDispositionEnum];

/**
 * 
 * @export
 * @interface Sites
 */
export interface Sites {
    /**
     * Note: This is a Foreign Key to `accounts.id`.<fk table=\'accounts\' column=\'id\'/>
     * @type {string}
     * @memberof Sites
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'createdAt': string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Sites
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof Sites
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'street2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'county'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sites
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof Sites
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Sites
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'primaryContactID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'state'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sites
     */
    'taxExempt'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'taxID'?: string;
    /**
     * Note: This is a Foreign Key to `employees.id`.<fk table=\'employees\' column=\'id\'/>
     * @type {string}
     * @memberof Sites
     */
    'createdById'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sites
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface StorageUnitTypes
 */
export interface StorageUnitTypes {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageUnitTypes
     */
    'totalSf'?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'label'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StorageUnitTypes
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageUnitTypes
     */
    'storeprice'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageUnitTypes
     */
    'internetdiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageUnitTypes
     */
    'total_units'?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageUnitTypes
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface StorageUnits
 */
export interface StorageUnits {
    /**
     * 
     * @type {string}
     * @memberof StorageUnits
     */
    'created_at'?: string;
    /**
     * Note: This is a Foreign Key to `storage_unit_types.id`.<fk table=\'storage_unit_types\' column=\'id\'/>
     * @type {string}
     * @memberof StorageUnits
     */
    'typeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof StorageUnits
     */
    'available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StorageUnits
     */
    'building'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageUnits
     */
    'unit_number'?: number;
    /**
     * Note: This is a Foreign Key to `accounts.id`.<fk table=\'accounts\' column=\'id\'/>
     * @type {string}
     * @memberof StorageUnits
     */
    'tenantId'?: string;
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof StorageUnits
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageUnits
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TableCounts
 */
export interface TableCounts {
    /**
     * 
     * @type {string}
     * @memberof TableCounts
     */
    'schemaname'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableCounts
     */
    'relname'?: string;
    /**
     * 
     * @type {number}
     * @memberof TableCounts
     */
    'reltuples'?: number;
}
/**
 * 
 * @export
 * @interface TagsView
 */
export interface TagsView {
    /**
     * 
     * @type {string}
     * @memberof TagsView
     */
    'tags'?: string;
    /**
     * 
     * @type {number}
     * @memberof TagsView
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Timelogs
 */
export interface Timelogs {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Timelogs
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'endedAt'?: string;
    /**
     * Note: This is a Foreign Key to `timesheets.id`.<fk table=\'timesheets\' column=\'id\'/>
     * @type {string}
     * @memberof Timelogs
     */
    'timesheetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'employeeId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Timelogs
     */
    'approved': boolean;
    /**
     * Note: This is a Foreign Key to `employees.id`.<fk table=\'employees\' column=\'id\'/>
     * @type {string}
     * @memberof Timelogs
     */
    'approvedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timelogs
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Timesheets
 */
export interface Timesheets {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Timesheets
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'endedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'employeeId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Timesheets
     */
    'approved': boolean;
    /**
     * Note: This is a Foreign Key to `employees.id`.<fk table=\'employees\' column=\'id\'/>
     * @type {string}
     * @memberof Timesheets
     */
    'approvedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Timesheets
     */
    'image'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Timesheets
     */
    'timelogs'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Timesheets
     */
    'timelogsCount': number;
}
/**
 * 
 * @export
 * @interface Transcriptions
 */
export interface Transcriptions {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Transcriptions
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'caller'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'callee'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'direction'?: string;
    /**
     * Note: This is a Foreign Key to `accounts.id`.<fk table=\'accounts\' column=\'id\'/>
     * @type {string}
     * @memberof Transcriptions
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'transcription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'audio_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transcriptions
     */
    'partner_number'?: string;
}
/**
 * 
 * @export
 * @interface Views
 */
export interface Views {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Views
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Views
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Views
     */
    'ip_address'?: string;
    /**
     * Note: This is a Foreign Key to `products.id`.<fk table=\'products\' column=\'id\'/>
     * @type {string}
     * @memberof Views
     */
    'product_id'?: string;
}
/**
 * 
 * @export
 * @interface WorkOrderType
 */
export interface WorkOrderType {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof WorkOrderType
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof WorkOrderType
     */
    'comment'?: string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (commercial !== undefined) {
                localVarQueryParameter['commercial'] = commercial;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (acquisitionDate !== undefined) {
                localVarQueryParameter['acquisitionDate'] = acquisitionDate;
            }

            if (leadSourceID !== undefined) {
                localVarQueryParameter['leadSourceID'] = leadSourceID;
            }

            if (billingAddress !== undefined) {
                localVarQueryParameter['billingAddress'] = billingAddress;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (paymentTerm !== undefined) {
                localVarQueryParameter['paymentTerm'] = paymentTerm;
            }

            if (doNotMail !== undefined) {
                localVarQueryParameter['doNotMail'] = doNotMail;
            }

            if (doNotEmail !== undefined) {
                localVarQueryParameter['doNotEmail'] = doNotEmail;
            }

            if (billingLocation !== undefined) {
                localVarQueryParameter['billingLocation'] = billingLocation;
            }

            if (doNotCall !== undefined) {
                localVarQueryParameter['doNotCall'] = doNotCall;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (lastStatementDate !== undefined) {
                localVarQueryParameter['lastStatementDate'] = lastStatementDate;
            }

            if (fax !== undefined) {
                localVarQueryParameter['fax'] = fax;
            }

            if (phones !== undefined) {
                localVarQueryParameter['phones'] = phones;
            }

            if (phoneNumbersList !== undefined) {
                localVarQueryParameter['phoneNumbersList'] = phoneNumbersList;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (phoneNumbersSearch !== undefined) {
                localVarQueryParameter['phoneNumbersSearch'] = phoneNumbersSearch;
            }

            if (transcriptions !== undefined) {
                localVarQueryParameter['transcriptions'] = transcriptions;
            }

            if (fts !== undefined) {
                localVarQueryParameter['fts'] = fts;
            }

            if (addressText !== undefined) {
                localVarQueryParameter['addressText'] = addressText;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (commercial !== undefined) {
                localVarQueryParameter['commercial'] = commercial;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (acquisitionDate !== undefined) {
                localVarQueryParameter['acquisitionDate'] = acquisitionDate;
            }

            if (leadSourceID !== undefined) {
                localVarQueryParameter['leadSourceID'] = leadSourceID;
            }

            if (billingAddress !== undefined) {
                localVarQueryParameter['billingAddress'] = billingAddress;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (paymentTerm !== undefined) {
                localVarQueryParameter['paymentTerm'] = paymentTerm;
            }

            if (doNotMail !== undefined) {
                localVarQueryParameter['doNotMail'] = doNotMail;
            }

            if (doNotEmail !== undefined) {
                localVarQueryParameter['doNotEmail'] = doNotEmail;
            }

            if (billingLocation !== undefined) {
                localVarQueryParameter['billingLocation'] = billingLocation;
            }

            if (doNotCall !== undefined) {
                localVarQueryParameter['doNotCall'] = doNotCall;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (lastStatementDate !== undefined) {
                localVarQueryParameter['lastStatementDate'] = lastStatementDate;
            }

            if (fax !== undefined) {
                localVarQueryParameter['fax'] = fax;
            }

            if (phones !== undefined) {
                localVarQueryParameter['phones'] = phones;
            }

            if (phoneNumbersList !== undefined) {
                localVarQueryParameter['phoneNumbersList'] = phoneNumbersList;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (phoneNumbersSearch !== undefined) {
                localVarQueryParameter['phoneNumbersSearch'] = phoneNumbersSearch;
            }

            if (transcriptions !== undefined) {
                localVarQueryParameter['transcriptions'] = transcriptions;
            }

            if (fts !== undefined) {
                localVarQueryParameter['fts'] = fts;
            }

            if (addressText !== undefined) {
                localVarQueryParameter['addressText'] = addressText;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch: async (accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (commercial !== undefined) {
                localVarQueryParameter['commercial'] = commercial;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (acquisitionDate !== undefined) {
                localVarQueryParameter['acquisitionDate'] = acquisitionDate;
            }

            if (leadSourceID !== undefined) {
                localVarQueryParameter['leadSourceID'] = leadSourceID;
            }

            if (billingAddress !== undefined) {
                localVarQueryParameter['billingAddress'] = billingAddress;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (paymentTerm !== undefined) {
                localVarQueryParameter['paymentTerm'] = paymentTerm;
            }

            if (doNotMail !== undefined) {
                localVarQueryParameter['doNotMail'] = doNotMail;
            }

            if (doNotEmail !== undefined) {
                localVarQueryParameter['doNotEmail'] = doNotEmail;
            }

            if (billingLocation !== undefined) {
                localVarQueryParameter['billingLocation'] = billingLocation;
            }

            if (doNotCall !== undefined) {
                localVarQueryParameter['doNotCall'] = doNotCall;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (lastStatementDate !== undefined) {
                localVarQueryParameter['lastStatementDate'] = lastStatementDate;
            }

            if (fax !== undefined) {
                localVarQueryParameter['fax'] = fax;
            }

            if (phones !== undefined) {
                localVarQueryParameter['phones'] = phones;
            }

            if (phoneNumbersList !== undefined) {
                localVarQueryParameter['phoneNumbersList'] = phoneNumbersList;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (phoneNumbersSearch !== undefined) {
                localVarQueryParameter['phoneNumbersSearch'] = phoneNumbersSearch;
            }

            if (transcriptions !== undefined) {
                localVarQueryParameter['transcriptions'] = transcriptions;
            }

            if (fts !== undefined) {
                localVarQueryParameter['fts'] = fts;
            }

            if (addressText !== undefined) {
                localVarQueryParameter['addressText'] = addressText;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accounts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accounts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Accounts>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPatch(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPatch(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(select, prefer, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.accountsDelete(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Accounts>> {
            return localVarFp.accountsGet(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountName] 
         * @param {string} [id] 
         * @param {boolean} [commercial] 
         * @param {string} [accountType] 
         * @param {string} [email] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [imageUrl] 
         * @param {string} [acquisitionDate] 
         * @param {string} [leadSourceID] 
         * @param {string} [billingAddress] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [paymentTerm] 
         * @param {boolean} [doNotMail] 
         * @param {boolean} [doNotEmail] 
         * @param {string} [billingLocation] 
         * @param {boolean} [doNotCall] 
         * @param {string} [comment] 
         * @param {string} [lastStatementDate] 
         * @param {string} [fax] 
         * @param {string} [phones] 
         * @param {string} [phoneNumbersList] 
         * @param {string} [createdById] 
         * @param {string} [phoneNumbersSearch] 
         * @param {string} [transcriptions] 
         * @param {string} [fts] 
         * @param {string} [addressText] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: any): AxiosPromise<void> {
            return localVarFp.accountsPatch(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Accounts} [accounts] accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: any): AxiosPromise<void> {
            return localVarFp.accountsPost(select, prefer, accounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {string} [accountName] 
     * @param {string} [id] 
     * @param {boolean} [commercial] 
     * @param {string} [accountType] 
     * @param {string} [email] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [imageUrl] 
     * @param {string} [acquisitionDate] 
     * @param {string} [leadSourceID] 
     * @param {string} [billingAddress] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [paymentTerm] 
     * @param {boolean} [doNotMail] 
     * @param {boolean} [doNotEmail] 
     * @param {string} [billingLocation] 
     * @param {boolean} [doNotCall] 
     * @param {string} [comment] 
     * @param {string} [lastStatementDate] 
     * @param {string} [fax] 
     * @param {string} [phones] 
     * @param {string} [phoneNumbersList] 
     * @param {string} [createdById] 
     * @param {string} [phoneNumbersSearch] 
     * @param {string} [transcriptions] 
     * @param {string} [fts] 
     * @param {string} [addressText] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsDelete(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsDelete(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountName] 
     * @param {string} [id] 
     * @param {boolean} [commercial] 
     * @param {string} [accountType] 
     * @param {string} [email] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [imageUrl] 
     * @param {string} [acquisitionDate] 
     * @param {string} [leadSourceID] 
     * @param {string} [billingAddress] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [paymentTerm] 
     * @param {boolean} [doNotMail] 
     * @param {boolean} [doNotEmail] 
     * @param {string} [billingLocation] 
     * @param {boolean} [doNotCall] 
     * @param {string} [comment] 
     * @param {string} [lastStatementDate] 
     * @param {string} [fax] 
     * @param {string} [phones] 
     * @param {string} [phoneNumbersList] 
     * @param {string} [createdById] 
     * @param {string} [phoneNumbersSearch] 
     * @param {string} [transcriptions] 
     * @param {string} [fts] 
     * @param {string} [addressText] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsGet(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsGet(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountName] 
     * @param {string} [id] 
     * @param {boolean} [commercial] 
     * @param {string} [accountType] 
     * @param {string} [email] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [imageUrl] 
     * @param {string} [acquisitionDate] 
     * @param {string} [leadSourceID] 
     * @param {string} [billingAddress] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [paymentTerm] 
     * @param {boolean} [doNotMail] 
     * @param {boolean} [doNotEmail] 
     * @param {string} [billingLocation] 
     * @param {boolean} [doNotCall] 
     * @param {string} [comment] 
     * @param {string} [lastStatementDate] 
     * @param {string} [fax] 
     * @param {string} [phones] 
     * @param {string} [phoneNumbersList] 
     * @param {string} [createdById] 
     * @param {string} [phoneNumbersSearch] 
     * @param {string} [transcriptions] 
     * @param {string} [fts] 
     * @param {string} [addressText] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Accounts} [accounts] accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPatch(accountName?: string, id?: string, commercial?: boolean, accountType?: string, email?: string, firstName?: string, lastName?: string, taxExempt?: boolean, taxID?: string, imageUrl?: string, acquisitionDate?: string, leadSourceID?: string, billingAddress?: string, createdAt?: string, updatedAt?: string, active?: boolean, paymentTerm?: string, doNotMail?: boolean, doNotEmail?: boolean, billingLocation?: string, doNotCall?: boolean, comment?: string, lastStatementDate?: string, fax?: string, phones?: string, phoneNumbersList?: string, createdById?: string, phoneNumbersSearch?: string, transcriptions?: string, fts?: string, addressText?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPatch(accountName, id, commercial, accountType, email, firstName, lastName, taxExempt, taxID, imageUrl, acquisitionDate, leadSourceID, billingAddress, createdAt, updatedAt, active, paymentTerm, doNotMail, doNotEmail, billingLocation, doNotCall, comment, lastStatementDate, fax, phones, phoneNumbersList, createdById, phoneNumbersSearch, transcriptions, fts, addressText, prefer, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Accounts} [accounts] accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', accounts?: Accounts, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPost(select, prefer, accounts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CallTranscriptionsApi - axios parameter creator
 * @export
 */
export const CallTranscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsDelete: async (id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/call_transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (rawTranscription !== undefined) {
                localVarQueryParameter['raw_transcription'] = rawTranscription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (datetime !== undefined) {
                localVarQueryParameter['datetime'] = datetime;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsGet: async (id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/call_transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (rawTranscription !== undefined) {
                localVarQueryParameter['raw_transcription'] = rawTranscription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (datetime !== undefined) {
                localVarQueryParameter['datetime'] = datetime;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsPatch: async (id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/call_transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (rawTranscription !== undefined) {
                localVarQueryParameter['raw_transcription'] = rawTranscription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (datetime !== undefined) {
                localVarQueryParameter['datetime'] = datetime;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callTranscriptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/call_transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callTranscriptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallTranscriptionsApi - functional programming interface
 * @export
 */
export const CallTranscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallTranscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callTranscriptionsDelete(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callTranscriptionsDelete(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callTranscriptionsGet(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CallTranscriptions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callTranscriptionsGet(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callTranscriptionsPatch(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callTranscriptionsPatch(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, callTranscriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callTranscriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callTranscriptionsPost(select, prefer, callTranscriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CallTranscriptionsApi - factory interface
 * @export
 */
export const CallTranscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallTranscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsDelete(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.callTranscriptionsDelete(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsGet(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<CallTranscriptions>> {
            return localVarFp.callTranscriptionsGet(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [id] 
         * @param {string} [rawTranscription] raw transcription
         * @param {string} [audioLocation] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [partnerNumber] 
         * @param {string} [accountId] 
         * @param {string} [direction] 
         * @param {string} [datetime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsPatch(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: any): AxiosPromise<void> {
            return localVarFp.callTranscriptionsPatch(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, callTranscriptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary recevied from cloud run or cloud function
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callTranscriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: any): AxiosPromise<void> {
            return localVarFp.callTranscriptionsPost(select, prefer, callTranscriptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallTranscriptionsApi - object-oriented interface
 * @export
 * @class CallTranscriptionsApi
 * @extends {BaseAPI}
 */
export class CallTranscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary recevied from cloud run or cloud function
     * @param {string} [id] 
     * @param {string} [rawTranscription] raw transcription
     * @param {string} [audioLocation] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [partnerNumber] 
     * @param {string} [accountId] 
     * @param {string} [direction] 
     * @param {string} [datetime] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTranscriptionsApi
     */
    public callTranscriptionsDelete(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return CallTranscriptionsApiFp(this.configuration).callTranscriptionsDelete(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary recevied from cloud run or cloud function
     * @param {string} [id] 
     * @param {string} [rawTranscription] raw transcription
     * @param {string} [audioLocation] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [partnerNumber] 
     * @param {string} [accountId] 
     * @param {string} [direction] 
     * @param {string} [datetime] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTranscriptionsApi
     */
    public callTranscriptionsGet(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return CallTranscriptionsApiFp(this.configuration).callTranscriptionsGet(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary recevied from cloud run or cloud function
     * @param {string} [id] 
     * @param {string} [rawTranscription] raw transcription
     * @param {string} [audioLocation] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [partnerNumber] 
     * @param {string} [accountId] 
     * @param {string} [direction] 
     * @param {string} [datetime] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTranscriptionsApi
     */
    public callTranscriptionsPatch(id?: string, rawTranscription?: string, audioLocation?: string, caller?: string, callee?: string, partnerNumber?: string, accountId?: string, direction?: string, datetime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: AxiosRequestConfig) {
        return CallTranscriptionsApiFp(this.configuration).callTranscriptionsPatch(id, rawTranscription, audioLocation, caller, callee, partnerNumber, accountId, direction, datetime, prefer, callTranscriptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary recevied from cloud run or cloud function
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {CallTranscriptions} [callTranscriptions] call_transcriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallTranscriptionsApi
     */
    public callTranscriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', callTranscriptions?: CallTranscriptions, options?: AxiosRequestConfig) {
        return CallTranscriptionsApiFp(this.configuration).callTranscriptionsPost(select, prefer, callTranscriptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceEventsApi - axios parameter creator
 * @export
 */
export const DeviceEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsDelete: async (id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (locationData !== undefined) {
                localVarQueryParameter['locationData'] = locationData;
            }

            if (locationString !== undefined) {
                localVarQueryParameter['locationString'] = locationString;
            }

            if (clientTime !== undefined) {
                localVarQueryParameter['clientTime'] = clientTime;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsGet: async (id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (locationData !== undefined) {
                localVarQueryParameter['locationData'] = locationData;
            }

            if (locationString !== undefined) {
                localVarQueryParameter['locationString'] = locationString;
            }

            if (clientTime !== undefined) {
                localVarQueryParameter['clientTime'] = clientTime;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsPatch: async (id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (locationData !== undefined) {
                localVarQueryParameter['locationData'] = locationData;
            }

            if (locationString !== undefined) {
                localVarQueryParameter['locationString'] = locationString;
            }

            if (clientTime !== undefined) {
                localVarQueryParameter['clientTime'] = clientTime;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceEvents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceEvents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceEventsApi - functional programming interface
 * @export
 */
export const DeviceEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceEventsDelete(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceEventsDelete(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceEventsGet(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceEvents>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceEventsGet(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceEventsPatch(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceEventsPatch(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, deviceEvents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceEventsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceEventsPost(select, prefer, deviceEvents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceEventsApi - factory interface
 * @export
 */
export const DeviceEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceEventsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsDelete(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.deviceEventsDelete(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsGet(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<DeviceEvents>> {
            return localVarFp.deviceEventsGet(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [deviceId] 
         * @param {string} [locationData] 
         * @param {string} [locationString] 
         * @param {string} [clientTime] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsPatch(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: any): AxiosPromise<void> {
            return localVarFp.deviceEventsPatch(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, deviceEvents, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {DeviceEvents} [deviceEvents] device_events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceEventsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: any): AxiosPromise<void> {
            return localVarFp.deviceEventsPost(select, prefer, deviceEvents, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceEventsApi - object-oriented interface
 * @export
 * @class DeviceEventsApi
 * @extends {BaseAPI}
 */
export class DeviceEventsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [deviceId] 
     * @param {string} [locationData] 
     * @param {string} [locationString] 
     * @param {string} [clientTime] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEventsApi
     */
    public deviceEventsDelete(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return DeviceEventsApiFp(this.configuration).deviceEventsDelete(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [deviceId] 
     * @param {string} [locationData] 
     * @param {string} [locationString] 
     * @param {string} [clientTime] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEventsApi
     */
    public deviceEventsGet(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return DeviceEventsApiFp(this.configuration).deviceEventsGet(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [deviceId] 
     * @param {string} [locationData] 
     * @param {string} [locationString] 
     * @param {string} [clientTime] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {DeviceEvents} [deviceEvents] device_events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEventsApi
     */
    public deviceEventsPatch(id?: string, createdAt?: string, updatedAt?: string, deviceId?: string, locationData?: string, locationString?: string, clientTime?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: AxiosRequestConfig) {
        return DeviceEventsApiFp(this.configuration).deviceEventsPatch(id, createdAt, updatedAt, deviceId, locationData, locationString, clientTime, prefer, deviceEvents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {DeviceEvents} [deviceEvents] device_events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceEventsApi
     */
    public deviceEventsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', deviceEvents?: DeviceEvents, options?: AxiosRequestConfig) {
        return DeviceEventsApiFp(this.configuration).deviceEventsPost(select, prefer, deviceEvents, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesDelete: async (id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGet: async (id?: string, createdAt?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPatch: async (id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(devices, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(devices, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesDelete(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesDelete(id, createdAt, updatedAt, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGet(id?: string, createdAt?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Devices>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesGet(id, createdAt, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPatch(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPatch(id, createdAt, updatedAt, prefer, devices, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPost(select, prefer, devices, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesDelete(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.devicesDelete(id, createdAt, updatedAt, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGet(id?: string, createdAt?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Devices>> {
            return localVarFp.devicesGet(id, createdAt, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPatch(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: any): AxiosPromise<void> {
            return localVarFp.devicesPatch(id, createdAt, updatedAt, prefer, devices, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Devices} [devices] devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: any): AxiosPromise<void> {
            return localVarFp.devicesPost(select, prefer, devices, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesDelete(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesDelete(id, createdAt, updatedAt, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesGet(id?: string, createdAt?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesGet(id, createdAt, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Devices} [devices] devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPatch(id?: string, createdAt?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPatch(id, createdAt, updatedAt, prefer, devices, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Devices} [devices] devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', devices?: Devices, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPost(select, prefer, devices, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmployeesApi - axios parameter creator
 * @export
 */
export const EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesDelete: async (createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (employeename !== undefined) {
                localVarQueryParameter['employeename'] = employeename;
            }

            if (lastSeen !== undefined) {
                localVarQueryParameter['lastSeen'] = lastSeen;
            }

            if (onsipId !== undefined) {
                localVarQueryParameter['onsipId'] = onsipId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (bio !== undefined) {
                localVarQueryParameter['bio'] = bio;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesGet: async (createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (employeename !== undefined) {
                localVarQueryParameter['employeename'] = employeename;
            }

            if (lastSeen !== undefined) {
                localVarQueryParameter['lastSeen'] = lastSeen;
            }

            if (onsipId !== undefined) {
                localVarQueryParameter['onsipId'] = onsipId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (bio !== undefined) {
                localVarQueryParameter['bio'] = bio;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPatch: async (createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (employeename !== undefined) {
                localVarQueryParameter['employeename'] = employeename;
            }

            if (lastSeen !== undefined) {
                localVarQueryParameter['lastSeen'] = lastSeen;
            }

            if (onsipId !== undefined) {
                localVarQueryParameter['onsipId'] = onsipId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (bio !== undefined) {
                localVarQueryParameter['bio'] = bio;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employees, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employees, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeesApi - functional programming interface
 * @export
 */
export const EmployeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesDelete(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesDelete(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesGet(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Employees>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesGet(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesPatch(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesPatch(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, employees, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeesPost(select, prefer, employees, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmployeesApi - factory interface
 * @export
 */
export const EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesDelete(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.employeesDelete(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesGet(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Employees>> {
            return localVarFp.employeesGet(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstName] 
         * @param {string} [id] 
         * @param {string} [lastName] 
         * @param {string} [password] 
         * @param {string} [roles] 
         * @param {boolean} [active] 
         * @param {string} [updatedAt] 
         * @param {string} [employeename] 
         * @param {string} [lastSeen] 
         * @param {string} [onsipId] 
         * @param {string} [email] 
         * @param {string} [avatarUrl] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [office] 
         * @param {string} [phone] 
         * @param {string} [bio] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPatch(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: any): AxiosPromise<void> {
            return localVarFp.employeesPatch(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, employees, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Employees} [employees] employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: any): AxiosPromise<void> {
            return localVarFp.employeesPost(select, prefer, employees, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeesApi - object-oriented interface
 * @export
 * @class EmployeesApi
 * @extends {BaseAPI}
 */
export class EmployeesApi extends BaseAPI {
    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstName] 
     * @param {string} [id] 
     * @param {string} [lastName] 
     * @param {string} [password] 
     * @param {string} [roles] 
     * @param {boolean} [active] 
     * @param {string} [updatedAt] 
     * @param {string} [employeename] 
     * @param {string} [lastSeen] 
     * @param {string} [onsipId] 
     * @param {string} [email] 
     * @param {string} [avatarUrl] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [office] 
     * @param {string} [phone] 
     * @param {string} [bio] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesDelete(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesDelete(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstName] 
     * @param {string} [id] 
     * @param {string} [lastName] 
     * @param {string} [password] 
     * @param {string} [roles] 
     * @param {boolean} [active] 
     * @param {string} [updatedAt] 
     * @param {string} [employeename] 
     * @param {string} [lastSeen] 
     * @param {string} [onsipId] 
     * @param {string} [email] 
     * @param {string} [avatarUrl] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [office] 
     * @param {string} [phone] 
     * @param {string} [bio] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesGet(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesGet(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstName] 
     * @param {string} [id] 
     * @param {string} [lastName] 
     * @param {string} [password] 
     * @param {string} [roles] 
     * @param {boolean} [active] 
     * @param {string} [updatedAt] 
     * @param {string} [employeename] 
     * @param {string} [lastSeen] 
     * @param {string} [onsipId] 
     * @param {string} [email] 
     * @param {string} [avatarUrl] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [office] 
     * @param {string} [phone] 
     * @param {string} [bio] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Employees} [employees] employees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesPatch(createdAt?: string, firstName?: string, id?: string, lastName?: string, password?: string, roles?: string, active?: boolean, updatedAt?: string, employeename?: string, lastSeen?: string, onsipId?: string, email?: string, avatarUrl?: string, description?: string, name?: string, office?: string, phone?: string, bio?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesPatch(createdAt, firstName, id, lastName, password, roles, active, updatedAt, employeename, lastSeen, onsipId, email, avatarUrl, description, name, office, phone, bio, prefer, employees, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Employees} [employees] employees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public employeesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', employees?: Employees, options?: AxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).employeesPost(select, prefer, employees, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FollowingsApi - axios parameter creator
 * @export
 */
export const FollowingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsDelete: async (id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (followingId !== undefined) {
                localVarQueryParameter['followingId'] = followingId;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsGet: async (id?: string, createdAt?: string, userId?: string, followingId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (followingId !== undefined) {
                localVarQueryParameter['followingId'] = followingId;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsPatch: async (id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (followingId !== undefined) {
                localVarQueryParameter['followingId'] = followingId;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowingsApi - functional programming interface
 * @export
 */
export const FollowingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followingsDelete(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followingsDelete(id, createdAt, userId, followingId, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followingsGet(id?: string, createdAt?: string, userId?: string, followingId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Followings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followingsGet(id, createdAt, userId, followingId, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followingsPatch(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followingsPatch(id, createdAt, userId, followingId, prefer, followings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followingsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followingsPost(select, prefer, followings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FollowingsApi - factory interface
 * @export
 */
export const FollowingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowingsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsDelete(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.followingsDelete(id, createdAt, userId, followingId, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsGet(id?: string, createdAt?: string, userId?: string, followingId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Followings>> {
            return localVarFp.followingsGet(id, createdAt, userId, followingId, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [followingId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsPatch(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: any): AxiosPromise<void> {
            return localVarFp.followingsPatch(id, createdAt, userId, followingId, prefer, followings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Followings} [followings] followings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: any): AxiosPromise<void> {
            return localVarFp.followingsPost(select, prefer, followings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowingsApi - object-oriented interface
 * @export
 * @class FollowingsApi
 * @extends {BaseAPI}
 */
export class FollowingsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [followingId] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowingsApi
     */
    public followingsDelete(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return FollowingsApiFp(this.configuration).followingsDelete(id, createdAt, userId, followingId, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [followingId] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowingsApi
     */
    public followingsGet(id?: string, createdAt?: string, userId?: string, followingId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return FollowingsApiFp(this.configuration).followingsGet(id, createdAt, userId, followingId, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [followingId] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Followings} [followings] followings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowingsApi
     */
    public followingsPatch(id?: string, createdAt?: string, userId?: string, followingId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: AxiosRequestConfig) {
        return FollowingsApiFp(this.configuration).followingsPatch(id, createdAt, userId, followingId, prefer, followings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Followings} [followings] followings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowingsApi
     */
    public followingsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', followings?: Followings, options?: AxiosRequestConfig) {
        return FollowingsApiFp(this.configuration).followingsPost(select, prefer, followings, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntrospectionApi - axios parameter creator
 * @export
 */
export const IntrospectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntrospectionApi - functional programming interface
 * @export
 */
export const IntrospectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntrospectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntrospectionApi - factory interface
 * @export
 */
export const IntrospectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntrospectionApiFp(configuration)
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntrospectionApi - object-oriented interface
 * @export
 * @class IntrospectionApi
 * @extends {BaseAPI}
 */
export class IntrospectionApi extends BaseAPI {
    /**
     * 
     * @summary OpenAPI description (this document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntrospectionApi
     */
    public rootGet(options?: AxiosRequestConfig) {
        return IntrospectionApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LineitemsApi - axios parameter creator
 * @export
 */
export const LineitemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsDelete: async (createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lineitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderId !== undefined) {
                localVarQueryParameter['workOrderId'] = workOrderId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (rowIndex !== undefined) {
                localVarQueryParameter['rowIndex'] = rowIndex;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (serviceDate !== undefined) {
                localVarQueryParameter['serviceDate'] = serviceDate;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsale !== undefined) {
                localVarQueryParameter['upsale'] = upsale;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (orderItemId !== undefined) {
                localVarQueryParameter['orderItemId'] = orderItemId;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (lineItemStatus !== undefined) {
                localVarQueryParameter['lineItemStatus'] = lineItemStatus;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (imageList !== undefined) {
                localVarQueryParameter['imageList'] = imageList;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsGet: async (createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lineitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderId !== undefined) {
                localVarQueryParameter['workOrderId'] = workOrderId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (rowIndex !== undefined) {
                localVarQueryParameter['rowIndex'] = rowIndex;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (serviceDate !== undefined) {
                localVarQueryParameter['serviceDate'] = serviceDate;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsale !== undefined) {
                localVarQueryParameter['upsale'] = upsale;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (orderItemId !== undefined) {
                localVarQueryParameter['orderItemId'] = orderItemId;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (lineItemStatus !== undefined) {
                localVarQueryParameter['lineItemStatus'] = lineItemStatus;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (imageList !== undefined) {
                localVarQueryParameter['imageList'] = imageList;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsPatch: async (createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lineitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderId !== undefined) {
                localVarQueryParameter['workOrderId'] = workOrderId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (rowIndex !== undefined) {
                localVarQueryParameter['rowIndex'] = rowIndex;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (serviceDate !== undefined) {
                localVarQueryParameter['serviceDate'] = serviceDate;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsale !== undefined) {
                localVarQueryParameter['upsale'] = upsale;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (orderItemId !== undefined) {
                localVarQueryParameter['orderItemId'] = orderItemId;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (lineItemStatus !== undefined) {
                localVarQueryParameter['lineItemStatus'] = lineItemStatus;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (imageList !== undefined) {
                localVarQueryParameter['imageList'] = imageList;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineitems, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lineitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineitems, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LineitemsApi - functional programming interface
 * @export
 */
export const LineitemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LineitemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lineitemsDelete(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lineitemsDelete(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lineitemsGet(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lineitems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lineitemsGet(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lineitemsPatch(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lineitemsPatch(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, lineitems, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lineitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lineitemsPost(select, prefer, lineitems, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LineitemsApi - factory interface
 * @export
 */
export const LineitemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LineitemsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsDelete(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.lineitemsDelete(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsGet(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Lineitems>> {
            return localVarFp.lineitemsGet(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [workOrderId] 
         * @param {string} [updatedAt] 
         * @param {number} [rowIndex] 
         * @param {number} [quantity] 
         * @param {string} [price] 
         * @param {string} [serviceDate] 
         * @param {string} [total] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsale] 
         * @param {string} [itemName] 
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [orderId] 
         * @param {string} [orderItemId] 
         * @param {string} [image] 
         * @param {string} [lineItemStatus] 
         * @param {string} [tags] 
         * @param {string} [imageList] 
         * @param {string} [status] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsPatch(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: any): AxiosPromise<void> {
            return localVarFp.lineitemsPatch(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, lineitems, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Lineitems} [lineitems] lineitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: any): AxiosPromise<void> {
            return localVarFp.lineitemsPost(select, prefer, lineitems, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LineitemsApi - object-oriented interface
 * @export
 * @class LineitemsApi
 * @extends {BaseAPI}
 */
export class LineitemsApi extends BaseAPI {
    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [workOrderId] 
     * @param {string} [updatedAt] 
     * @param {number} [rowIndex] 
     * @param {number} [quantity] 
     * @param {string} [price] 
     * @param {string} [serviceDate] 
     * @param {string} [total] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsale] 
     * @param {string} [itemName] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [orderId] 
     * @param {string} [orderItemId] 
     * @param {string} [image] 
     * @param {string} [lineItemStatus] 
     * @param {string} [tags] 
     * @param {string} [imageList] 
     * @param {string} [status] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineitemsApi
     */
    public lineitemsDelete(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return LineitemsApiFp(this.configuration).lineitemsDelete(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [workOrderId] 
     * @param {string} [updatedAt] 
     * @param {number} [rowIndex] 
     * @param {number} [quantity] 
     * @param {string} [price] 
     * @param {string} [serviceDate] 
     * @param {string} [total] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsale] 
     * @param {string} [itemName] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [orderId] 
     * @param {string} [orderItemId] 
     * @param {string} [image] 
     * @param {string} [lineItemStatus] 
     * @param {string} [tags] 
     * @param {string} [imageList] 
     * @param {string} [status] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineitemsApi
     */
    public lineitemsGet(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return LineitemsApiFp(this.configuration).lineitemsGet(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [workOrderId] 
     * @param {string} [updatedAt] 
     * @param {number} [rowIndex] 
     * @param {number} [quantity] 
     * @param {string} [price] 
     * @param {string} [serviceDate] 
     * @param {string} [total] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsale] 
     * @param {string} [itemName] 
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [orderId] 
     * @param {string} [orderItemId] 
     * @param {string} [image] 
     * @param {string} [lineItemStatus] 
     * @param {string} [tags] 
     * @param {string} [imageList] 
     * @param {string} [status] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Lineitems} [lineitems] lineitems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineitemsApi
     */
    public lineitemsPatch(createdAt?: string, id?: string, workOrderId?: string, updatedAt?: string, rowIndex?: number, quantity?: number, price?: string, serviceDate?: string, total?: string, taxed?: boolean, upsale?: boolean, itemName?: string, description?: string, name?: string, orderId?: string, orderItemId?: string, image?: string, lineItemStatus?: string, tags?: string, imageList?: string, status?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: AxiosRequestConfig) {
        return LineitemsApiFp(this.configuration).lineitemsPatch(createdAt, id, workOrderId, updatedAt, rowIndex, quantity, price, serviceDate, total, taxed, upsale, itemName, description, name, orderId, orderItemId, image, lineItemStatus, tags, imageList, status, prefer, lineitems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Lineitems} [lineitems] lineitems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineitemsApi
     */
    public lineitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', lineitems?: Lineitems, options?: AxiosRequestConfig) {
        return LineitemsApiFp(this.configuration).lineitemsPost(select, prefer, lineitems, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderitemsApi - axios parameter creator
 * @export
 */
export const OrderitemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsDelete: async (createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orderitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (addToFavorites !== undefined) {
                localVarQueryParameter['addToFavorites'] = addToFavorites;
            }

            if (commissionable !== undefined) {
                localVarQueryParameter['commissionable'] = commissionable;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['createdBy'] = createdBy;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (priceLocked !== undefined) {
                localVarQueryParameter['priceLocked'] = priceLocked;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (rowNumber !== undefined) {
                localVarQueryParameter['rowNumber'] = rowNumber;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsaleItem !== undefined) {
                localVarQueryParameter['upsaleItem'] = upsaleItem;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsGet: async (createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orderitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (addToFavorites !== undefined) {
                localVarQueryParameter['addToFavorites'] = addToFavorites;
            }

            if (commissionable !== undefined) {
                localVarQueryParameter['commissionable'] = commissionable;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['createdBy'] = createdBy;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (priceLocked !== undefined) {
                localVarQueryParameter['priceLocked'] = priceLocked;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (rowNumber !== undefined) {
                localVarQueryParameter['rowNumber'] = rowNumber;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsaleItem !== undefined) {
                localVarQueryParameter['upsaleItem'] = upsaleItem;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsPatch: async (createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orderitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (addToFavorites !== undefined) {
                localVarQueryParameter['addToFavorites'] = addToFavorites;
            }

            if (commissionable !== undefined) {
                localVarQueryParameter['commissionable'] = commissionable;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['createdBy'] = createdBy;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (priceLocked !== undefined) {
                localVarQueryParameter['priceLocked'] = priceLocked;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (rowNumber !== undefined) {
                localVarQueryParameter['rowNumber'] = rowNumber;
            }

            if (taxed !== undefined) {
                localVarQueryParameter['taxed'] = taxed;
            }

            if (upsaleItem !== undefined) {
                localVarQueryParameter['upsaleItem'] = upsaleItem;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderitems, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orderitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderitems, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderitemsApi - functional programming interface
 * @export
 */
export const OrderitemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderitemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderitemsDelete(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderitemsDelete(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderitemsGet(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Orderitems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderitemsGet(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderitemsPatch(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderitemsPatch(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, orderitems, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderitemsPost(select, prefer, orderitems, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderitemsApi - factory interface
 * @export
 */
export const OrderitemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderitemsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsDelete(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.orderitemsDelete(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsGet(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Orderitems>> {
            return localVarFp.orderitemsGet(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {boolean} [addToFavorites] 
         * @param {boolean} [commissionable] 
         * @param {string} [createdBy] 
         * @param {string} [description] 
         * @param {string} [itemGroup] 
         * @param {string} [itemType] 
         * @param {string} [name] 
         * @param {string} [price] 
         * @param {boolean} [priceLocked] 
         * @param {string} [quantity] 
         * @param {string} [rowNumber] 
         * @param {boolean} [taxed] 
         * @param {boolean} [upsaleItem] 
         * @param {string} [id] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsPatch(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: any): AxiosPromise<void> {
            return localVarFp.orderitemsPatch(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, orderitems, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orderitems} [orderitems] orderitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: any): AxiosPromise<void> {
            return localVarFp.orderitemsPost(select, prefer, orderitems, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderitemsApi - object-oriented interface
 * @export
 * @class OrderitemsApi
 * @extends {BaseAPI}
 */
export class OrderitemsApi extends BaseAPI {
    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {boolean} [addToFavorites] 
     * @param {boolean} [commissionable] 
     * @param {string} [createdBy] 
     * @param {string} [description] 
     * @param {string} [itemGroup] 
     * @param {string} [itemType] 
     * @param {string} [name] 
     * @param {string} [price] 
     * @param {boolean} [priceLocked] 
     * @param {string} [quantity] 
     * @param {string} [rowNumber] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsaleItem] 
     * @param {string} [id] 
     * @param {string} [image] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderitemsApi
     */
    public orderitemsDelete(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return OrderitemsApiFp(this.configuration).orderitemsDelete(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {boolean} [addToFavorites] 
     * @param {boolean} [commissionable] 
     * @param {string} [createdBy] 
     * @param {string} [description] 
     * @param {string} [itemGroup] 
     * @param {string} [itemType] 
     * @param {string} [name] 
     * @param {string} [price] 
     * @param {boolean} [priceLocked] 
     * @param {string} [quantity] 
     * @param {string} [rowNumber] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsaleItem] 
     * @param {string} [id] 
     * @param {string} [image] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderitemsApi
     */
    public orderitemsGet(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return OrderitemsApiFp(this.configuration).orderitemsGet(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {boolean} [addToFavorites] 
     * @param {boolean} [commissionable] 
     * @param {string} [createdBy] 
     * @param {string} [description] 
     * @param {string} [itemGroup] 
     * @param {string} [itemType] 
     * @param {string} [name] 
     * @param {string} [price] 
     * @param {boolean} [priceLocked] 
     * @param {string} [quantity] 
     * @param {string} [rowNumber] 
     * @param {boolean} [taxed] 
     * @param {boolean} [upsaleItem] 
     * @param {string} [id] 
     * @param {string} [image] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Orderitems} [orderitems] orderitems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderitemsApi
     */
    public orderitemsPatch(createdAt?: string, updatedAt?: string, active?: boolean, addToFavorites?: boolean, commissionable?: boolean, createdBy?: string, description?: string, itemGroup?: string, itemType?: string, name?: string, price?: string, priceLocked?: boolean, quantity?: string, rowNumber?: string, taxed?: boolean, upsaleItem?: boolean, id?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: AxiosRequestConfig) {
        return OrderitemsApiFp(this.configuration).orderitemsPatch(createdAt, updatedAt, active, addToFavorites, commissionable, createdBy, description, itemGroup, itemType, name, price, priceLocked, quantity, rowNumber, taxed, upsaleItem, id, image, prefer, orderitems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Orderitems} [orderitems] orderitems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderitemsApi
     */
    public orderitemsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orderitems?: Orderitems, options?: AxiosRequestConfig) {
        return OrderitemsApiFp(this.configuration).orderitemsPost(select, prefer, orderitems, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersDelete: async (accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (balanceDue !== undefined) {
                localVarQueryParameter['balanceDue'] = balanceDue;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (dateCompleted !== undefined) {
                localVarQueryParameter['dateCompleted'] = dateCompleted;
            }

            if (discountPercent !== undefined) {
                localVarQueryParameter['discountPercent'] = discountPercent;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (grandTotal !== undefined) {
                localVarQueryParameter['grandTotal'] = grandTotal;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (imagesFullUrlList !== undefined) {
                localVarQueryParameter['imagesFullUrlList'] = imagesFullUrlList;
            }

            if (imagesThumbUrlList !== undefined) {
                localVarQueryParameter['imagesThumbUrlList'] = imagesThumbUrlList;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (merchantFeesTotal !== undefined) {
                localVarQueryParameter['merchantFeesTotal'] = merchantFeesTotal;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (originalType !== undefined) {
                localVarQueryParameter['originalType'] = originalType;
            }

            if (refNumber !== undefined) {
                localVarQueryParameter['refNumber'] = refNumber;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['siteId'] = siteId;
            }

            if (subTotal !== undefined) {
                localVarQueryParameter['subTotal'] = subTotal;
            }

            if (taxId !== undefined) {
                localVarQueryParameter['taxId'] = taxId;
            }

            if (taxRate !== undefined) {
                localVarQueryParameter['taxRate'] = taxRate;
            }

            if (taxTotal !== undefined) {
                localVarQueryParameter['taxTotal'] = taxTotal;
            }

            if (tipCollected !== undefined) {
                localVarQueryParameter['tipCollected'] = tipCollected;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (updatedByName !== undefined) {
                localVarQueryParameter['updatedByName'] = updatedByName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderType !== undefined) {
                localVarQueryParameter['workOrderType'] = workOrderType;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersGet: async (accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (balanceDue !== undefined) {
                localVarQueryParameter['balanceDue'] = balanceDue;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (dateCompleted !== undefined) {
                localVarQueryParameter['dateCompleted'] = dateCompleted;
            }

            if (discountPercent !== undefined) {
                localVarQueryParameter['discountPercent'] = discountPercent;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (grandTotal !== undefined) {
                localVarQueryParameter['grandTotal'] = grandTotal;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (imagesFullUrlList !== undefined) {
                localVarQueryParameter['imagesFullUrlList'] = imagesFullUrlList;
            }

            if (imagesThumbUrlList !== undefined) {
                localVarQueryParameter['imagesThumbUrlList'] = imagesThumbUrlList;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (merchantFeesTotal !== undefined) {
                localVarQueryParameter['merchantFeesTotal'] = merchantFeesTotal;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (originalType !== undefined) {
                localVarQueryParameter['originalType'] = originalType;
            }

            if (refNumber !== undefined) {
                localVarQueryParameter['refNumber'] = refNumber;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['siteId'] = siteId;
            }

            if (subTotal !== undefined) {
                localVarQueryParameter['subTotal'] = subTotal;
            }

            if (taxId !== undefined) {
                localVarQueryParameter['taxId'] = taxId;
            }

            if (taxRate !== undefined) {
                localVarQueryParameter['taxRate'] = taxRate;
            }

            if (taxTotal !== undefined) {
                localVarQueryParameter['taxTotal'] = taxTotal;
            }

            if (tipCollected !== undefined) {
                localVarQueryParameter['tipCollected'] = tipCollected;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (updatedByName !== undefined) {
                localVarQueryParameter['updatedByName'] = updatedByName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderType !== undefined) {
                localVarQueryParameter['workOrderType'] = workOrderType;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPatch: async (accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (balanceDue !== undefined) {
                localVarQueryParameter['balanceDue'] = balanceDue;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (dateCompleted !== undefined) {
                localVarQueryParameter['dateCompleted'] = dateCompleted;
            }

            if (discountPercent !== undefined) {
                localVarQueryParameter['discountPercent'] = discountPercent;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (grandTotal !== undefined) {
                localVarQueryParameter['grandTotal'] = grandTotal;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (imagesFullUrlList !== undefined) {
                localVarQueryParameter['imagesFullUrlList'] = imagesFullUrlList;
            }

            if (imagesThumbUrlList !== undefined) {
                localVarQueryParameter['imagesThumbUrlList'] = imagesThumbUrlList;
            }

            if (itemGroup !== undefined) {
                localVarQueryParameter['itemGroup'] = itemGroup;
            }

            if (merchantFeesTotal !== undefined) {
                localVarQueryParameter['merchantFeesTotal'] = merchantFeesTotal;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (originalType !== undefined) {
                localVarQueryParameter['originalType'] = originalType;
            }

            if (refNumber !== undefined) {
                localVarQueryParameter['refNumber'] = refNumber;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['siteId'] = siteId;
            }

            if (subTotal !== undefined) {
                localVarQueryParameter['subTotal'] = subTotal;
            }

            if (taxId !== undefined) {
                localVarQueryParameter['taxId'] = taxId;
            }

            if (taxRate !== undefined) {
                localVarQueryParameter['taxRate'] = taxRate;
            }

            if (taxTotal !== undefined) {
                localVarQueryParameter['taxTotal'] = taxTotal;
            }

            if (tipCollected !== undefined) {
                localVarQueryParameter['tipCollected'] = tipCollected;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (updatedByName !== undefined) {
                localVarQueryParameter['updatedByName'] = updatedByName;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (workOrderType !== undefined) {
                localVarQueryParameter['workOrderType'] = workOrderType;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orders, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orders, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersDelete(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersDelete(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersGet(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Orders>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersGet(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPatch(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPatch(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, orders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPost(select, prefer, orders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersDelete(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.ordersDelete(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersGet(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Orders>> {
            return localVarFp.ordersGet(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {string} [balanceDue] 
         * @param {string} [createdAt] 
         * @param {string} [createdById] 
         * @param {string} [dateCompleted] 
         * @param {string} [discountPercent] 
         * @param {string} [dueDate] 
         * @param {string} [grandTotal] 
         * @param {string} [group] 
         * @param {string} [image] 
         * @param {string} [imagesFullUrlList] 
         * @param {string} [imagesThumbUrlList] 
         * @param {string} [itemGroup] 
         * @param {string} [merchantFeesTotal] 
         * @param {string} [note] 
         * @param {string} [notes] 
         * @param {number} [orderNumber] 
         * @param {string} [orderStatus] 
         * @param {string} [orderType] 
         * @param {string} [originalType] 
         * @param {string} [refNumber] 
         * @param {string} [siteId] 
         * @param {string} [subTotal] 
         * @param {string} [taxId] 
         * @param {string} [taxRate] 
         * @param {string} [taxTotal] 
         * @param {string} [tipCollected] 
         * @param {string} [updatedAt] 
         * @param {string} [updatedByName] 
         * @param {string} [id] 
         * @param {string} [workOrderType] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPatch(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: any): AxiosPromise<void> {
            return localVarFp.ordersPatch(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Orders} [orders] orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: any): AxiosPromise<void> {
            return localVarFp.ordersPost(select, prefer, orders, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [accountName] 
     * @param {string} [balanceDue] 
     * @param {string} [createdAt] 
     * @param {string} [createdById] 
     * @param {string} [dateCompleted] 
     * @param {string} [discountPercent] 
     * @param {string} [dueDate] 
     * @param {string} [grandTotal] 
     * @param {string} [group] 
     * @param {string} [image] 
     * @param {string} [imagesFullUrlList] 
     * @param {string} [imagesThumbUrlList] 
     * @param {string} [itemGroup] 
     * @param {string} [merchantFeesTotal] 
     * @param {string} [note] 
     * @param {string} [notes] 
     * @param {number} [orderNumber] 
     * @param {string} [orderStatus] 
     * @param {string} [orderType] 
     * @param {string} [originalType] 
     * @param {string} [refNumber] 
     * @param {string} [siteId] 
     * @param {string} [subTotal] 
     * @param {string} [taxId] 
     * @param {string} [taxRate] 
     * @param {string} [taxTotal] 
     * @param {string} [tipCollected] 
     * @param {string} [updatedAt] 
     * @param {string} [updatedByName] 
     * @param {string} [id] 
     * @param {string} [workOrderType] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersDelete(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersDelete(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [accountName] 
     * @param {string} [balanceDue] 
     * @param {string} [createdAt] 
     * @param {string} [createdById] 
     * @param {string} [dateCompleted] 
     * @param {string} [discountPercent] 
     * @param {string} [dueDate] 
     * @param {string} [grandTotal] 
     * @param {string} [group] 
     * @param {string} [image] 
     * @param {string} [imagesFullUrlList] 
     * @param {string} [imagesThumbUrlList] 
     * @param {string} [itemGroup] 
     * @param {string} [merchantFeesTotal] 
     * @param {string} [note] 
     * @param {string} [notes] 
     * @param {number} [orderNumber] 
     * @param {string} [orderStatus] 
     * @param {string} [orderType] 
     * @param {string} [originalType] 
     * @param {string} [refNumber] 
     * @param {string} [siteId] 
     * @param {string} [subTotal] 
     * @param {string} [taxId] 
     * @param {string} [taxRate] 
     * @param {string} [taxTotal] 
     * @param {string} [tipCollected] 
     * @param {string} [updatedAt] 
     * @param {string} [updatedByName] 
     * @param {string} [id] 
     * @param {string} [workOrderType] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersGet(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersGet(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [accountName] 
     * @param {string} [balanceDue] 
     * @param {string} [createdAt] 
     * @param {string} [createdById] 
     * @param {string} [dateCompleted] 
     * @param {string} [discountPercent] 
     * @param {string} [dueDate] 
     * @param {string} [grandTotal] 
     * @param {string} [group] 
     * @param {string} [image] 
     * @param {string} [imagesFullUrlList] 
     * @param {string} [imagesThumbUrlList] 
     * @param {string} [itemGroup] 
     * @param {string} [merchantFeesTotal] 
     * @param {string} [note] 
     * @param {string} [notes] 
     * @param {number} [orderNumber] 
     * @param {string} [orderStatus] 
     * @param {string} [orderType] 
     * @param {string} [originalType] 
     * @param {string} [refNumber] 
     * @param {string} [siteId] 
     * @param {string} [subTotal] 
     * @param {string} [taxId] 
     * @param {string} [taxRate] 
     * @param {string} [taxTotal] 
     * @param {string} [tipCollected] 
     * @param {string} [updatedAt] 
     * @param {string} [updatedByName] 
     * @param {string} [id] 
     * @param {string} [workOrderType] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Orders} [orders] orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPatch(accountId?: string, accountName?: string, balanceDue?: string, createdAt?: string, createdById?: string, dateCompleted?: string, discountPercent?: string, dueDate?: string, grandTotal?: string, group?: string, image?: string, imagesFullUrlList?: string, imagesThumbUrlList?: string, itemGroup?: string, merchantFeesTotal?: string, note?: string, notes?: string, orderNumber?: number, orderStatus?: string, orderType?: string, originalType?: string, refNumber?: string, siteId?: string, subTotal?: string, taxId?: string, taxRate?: string, taxTotal?: string, tipCollected?: string, updatedAt?: string, updatedByName?: string, id?: string, workOrderType?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPatch(accountId, accountName, balanceDue, createdAt, createdById, dateCompleted, discountPercent, dueDate, grandTotal, group, image, imagesFullUrlList, imagesThumbUrlList, itemGroup, merchantFeesTotal, note, notes, orderNumber, orderStatus, orderType, originalType, refNumber, siteId, subTotal, taxId, taxRate, taxTotal, tipCollected, updatedAt, updatedByName, id, workOrderType, prefer, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Orders} [orders] orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', orders?: Orders, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPost(select, prefer, orders, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete: async (id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (githubUrl !== undefined) {
                localVarQueryParameter['github_url'] = githubUrl;
            }

            if (twitter !== undefined) {
                localVarQueryParameter['twitter'] = twitter;
            }

            if (instagram !== undefined) {
                localVarQueryParameter['instagram'] = instagram;
            }

            if (images !== undefined) {
                localVarQueryParameter['images'] = images;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (supabaseFeatures !== undefined) {
                localVarQueryParameter['supabase_features'] = supabaseFeatures;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (githubUrl !== undefined) {
                localVarQueryParameter['github_url'] = githubUrl;
            }

            if (twitter !== undefined) {
                localVarQueryParameter['twitter'] = twitter;
            }

            if (instagram !== undefined) {
                localVarQueryParameter['instagram'] = instagram;
            }

            if (images !== undefined) {
                localVarQueryParameter['images'] = images;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (supabaseFeatures !== undefined) {
                localVarQueryParameter['supabase_features'] = supabaseFeatures;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (githubUrl !== undefined) {
                localVarQueryParameter['github_url'] = githubUrl;
            }

            if (twitter !== undefined) {
                localVarQueryParameter['twitter'] = twitter;
            }

            if (instagram !== undefined) {
                localVarQueryParameter['instagram'] = instagram;
            }

            if (images !== undefined) {
                localVarQueryParameter['images'] = images;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (supabaseFeatures !== undefined) {
                localVarQueryParameter['supabase_features'] = supabaseFeatures;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(products, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(products, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsDelete(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsDelete(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Products>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, products, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(select, prefer, products, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.productsDelete(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Products>> {
            return localVarFp.productsGet(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [email] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: any): AxiosPromise<void> {
            return localVarFp.productsPatch(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, products, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Products} [products] products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: any): AxiosPromise<void> {
            return localVarFp.productsPost(select, prefer, products, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [title] 
     * @param {string} [email] 
     * @param {string} [description] 
     * @param {string} [categories] 
     * @param {string} [url] 
     * @param {string} [githubUrl] 
     * @param {string} [twitter] 
     * @param {string} [instagram] 
     * @param {string} [images] 
     * @param {string} [slug] 
     * @param {string} [supabaseFeatures] 
     * @param {boolean} [approved] 
     * @param {string} [createdAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsDelete(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsDelete(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [title] 
     * @param {string} [email] 
     * @param {string} [description] 
     * @param {string} [categories] 
     * @param {string} [url] 
     * @param {string} [githubUrl] 
     * @param {string} [twitter] 
     * @param {string} [instagram] 
     * @param {string} [images] 
     * @param {string} [slug] 
     * @param {string} [supabaseFeatures] 
     * @param {boolean} [approved] 
     * @param {string} [createdAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [title] 
     * @param {string} [email] 
     * @param {string} [description] 
     * @param {string} [categories] 
     * @param {string} [url] 
     * @param {string} [githubUrl] 
     * @param {string} [twitter] 
     * @param {string} [instagram] 
     * @param {string} [images] 
     * @param {string} [slug] 
     * @param {string} [supabaseFeatures] 
     * @param {boolean} [approved] 
     * @param {string} [createdAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Products} [products] products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(id?: string, title?: string, email?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(id, title, email, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, prefer, products, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Products} [products] products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', products?: Products, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPost(select, prefer, products, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsViewApi - axios parameter creator
 * @export
 */
export const ProductsViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [views] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsViewGet: async (id?: string, title?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, views?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products_view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (githubUrl !== undefined) {
                localVarQueryParameter['github_url'] = githubUrl;
            }

            if (twitter !== undefined) {
                localVarQueryParameter['twitter'] = twitter;
            }

            if (instagram !== undefined) {
                localVarQueryParameter['instagram'] = instagram;
            }

            if (images !== undefined) {
                localVarQueryParameter['images'] = images;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (supabaseFeatures !== undefined) {
                localVarQueryParameter['supabase_features'] = supabaseFeatures;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (views !== undefined) {
                localVarQueryParameter['views'] = views;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsViewApi - functional programming interface
 * @export
 */
export const ProductsViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsViewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [views] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsViewGet(id?: string, title?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, views?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductsView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsViewGet(id, title, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, views, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsViewApi - factory interface
 * @export
 */
export const ProductsViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsViewApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [categories] 
         * @param {string} [url] 
         * @param {string} [githubUrl] 
         * @param {string} [twitter] 
         * @param {string} [instagram] 
         * @param {string} [images] 
         * @param {string} [slug] 
         * @param {string} [supabaseFeatures] 
         * @param {boolean} [approved] 
         * @param {string} [createdAt] 
         * @param {string} [views] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsViewGet(id?: string, title?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, views?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<ProductsView>> {
            return localVarFp.productsViewGet(id, title, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, views, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsViewApi - object-oriented interface
 * @export
 * @class ProductsViewApi
 * @extends {BaseAPI}
 */
export class ProductsViewApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [categories] 
     * @param {string} [url] 
     * @param {string} [githubUrl] 
     * @param {string} [twitter] 
     * @param {string} [instagram] 
     * @param {string} [images] 
     * @param {string} [slug] 
     * @param {string} [supabaseFeatures] 
     * @param {boolean} [approved] 
     * @param {string} [createdAt] 
     * @param {string} [views] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsViewApi
     */
    public productsViewGet(id?: string, title?: string, description?: string, categories?: string, url?: string, githubUrl?: string, twitter?: string, instagram?: string, images?: string, slug?: string, supabaseFeatures?: string, approved?: boolean, createdAt?: string, views?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return ProductsViewApiFp(this.configuration).productsViewGet(id, title, description, categories, url, githubUrl, twitter, instagram, images, slug, supabaseFeatures, approved, createdAt, views, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDelete: async (createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (avatar !== undefined) {
                localVarQueryParameter['avatar'] = avatar;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (theme !== undefined) {
                localVarQueryParameter['theme'] = theme;
            }

            if (tfaSecret !== undefined) {
                localVarQueryParameter['tfa_secret'] = tfaSecret;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (lastAccess !== undefined) {
                localVarQueryParameter['last_access'] = lastAccess;
            }

            if (lastPage !== undefined) {
                localVarQueryParameter['last_page'] = lastPage;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (externalIdentifier !== undefined) {
                localVarQueryParameter['external_identifier'] = externalIdentifier;
            }

            if (authData !== undefined) {
                localVarQueryParameter['auth_data'] = authData;
            }

            if (emailNotifications !== undefined) {
                localVarQueryParameter['email_notifications'] = emailNotifications;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet: async (createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (avatar !== undefined) {
                localVarQueryParameter['avatar'] = avatar;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (theme !== undefined) {
                localVarQueryParameter['theme'] = theme;
            }

            if (tfaSecret !== undefined) {
                localVarQueryParameter['tfa_secret'] = tfaSecret;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (lastAccess !== undefined) {
                localVarQueryParameter['last_access'] = lastAccess;
            }

            if (lastPage !== undefined) {
                localVarQueryParameter['last_page'] = lastPage;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (externalIdentifier !== undefined) {
                localVarQueryParameter['external_identifier'] = externalIdentifier;
            }

            if (authData !== undefined) {
                localVarQueryParameter['auth_data'] = authData;
            }

            if (emailNotifications !== undefined) {
                localVarQueryParameter['email_notifications'] = emailNotifications;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPatch: async (createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (firstname !== undefined) {
                localVarQueryParameter['firstname'] = firstname;
            }

            if (lastname !== undefined) {
                localVarQueryParameter['lastname'] = lastname;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (avatar !== undefined) {
                localVarQueryParameter['avatar'] = avatar;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (theme !== undefined) {
                localVarQueryParameter['theme'] = theme;
            }

            if (tfaSecret !== undefined) {
                localVarQueryParameter['tfa_secret'] = tfaSecret;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (lastAccess !== undefined) {
                localVarQueryParameter['last_access'] = lastAccess;
            }

            if (lastPage !== undefined) {
                localVarQueryParameter['last_page'] = lastPage;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (externalIdentifier !== undefined) {
                localVarQueryParameter['external_identifier'] = externalIdentifier;
            }

            if (authData !== undefined) {
                localVarQueryParameter['auth_data'] = authData;
            }

            if (emailNotifications !== undefined) {
                localVarQueryParameter['email_notifications'] = emailNotifications;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profiles, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profiles, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesDelete(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesDelete(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesGet(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Profiles>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesGet(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesPatch(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesPatch(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, profiles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesPost(select, prefer, profiles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDelete(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.profilesDelete(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Profiles>> {
            return localVarFp.profilesGet(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {string} [role] 
         * @param {string} [accountId] 
         * @param {string} [type] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {string} [location] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {string} [avatar] 
         * @param {string} [language] 
         * @param {string} [theme] 
         * @param {string} [tfaSecret] 
         * @param {string} [status] 
         * @param {string} [token] 
         * @param {string} [lastAccess] 
         * @param {string} [lastPage] 
         * @param {string} [provider] 
         * @param {string} [externalIdentifier] 
         * @param {string} [authData] 
         * @param {string} [emailNotifications] 
         * @param {string} [id] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPatch(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: any): AxiosPromise<void> {
            return localVarFp.profilesPatch(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, profiles, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Profiles} [profiles] profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: any): AxiosPromise<void> {
            return localVarFp.profilesPost(select, prefer, profiles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstname] 
     * @param {string} [lastname] 
     * @param {string} [role] 
     * @param {string} [accountId] 
     * @param {string} [type] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {string} [password] 
     * @param {string} [location] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [tags] 
     * @param {string} [avatar] 
     * @param {string} [language] 
     * @param {string} [theme] 
     * @param {string} [tfaSecret] 
     * @param {string} [status] 
     * @param {string} [token] 
     * @param {string} [lastAccess] 
     * @param {string} [lastPage] 
     * @param {string} [provider] 
     * @param {string} [externalIdentifier] 
     * @param {string} [authData] 
     * @param {string} [emailNotifications] 
     * @param {string} [id] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesDelete(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesDelete(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstname] 
     * @param {string} [lastname] 
     * @param {string} [role] 
     * @param {string} [accountId] 
     * @param {string} [type] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {string} [password] 
     * @param {string} [location] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [tags] 
     * @param {string} [avatar] 
     * @param {string} [language] 
     * @param {string} [theme] 
     * @param {string} [tfaSecret] 
     * @param {string} [status] 
     * @param {string} [token] 
     * @param {string} [lastAccess] 
     * @param {string} [lastPage] 
     * @param {string} [provider] 
     * @param {string} [externalIdentifier] 
     * @param {string} [authData] 
     * @param {string} [emailNotifications] 
     * @param {string} [id] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesGet(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesGet(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [firstname] 
     * @param {string} [lastname] 
     * @param {string} [role] 
     * @param {string} [accountId] 
     * @param {string} [type] 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {string} [password] 
     * @param {string} [location] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [tags] 
     * @param {string} [avatar] 
     * @param {string} [language] 
     * @param {string} [theme] 
     * @param {string} [tfaSecret] 
     * @param {string} [status] 
     * @param {string} [token] 
     * @param {string} [lastAccess] 
     * @param {string} [lastPage] 
     * @param {string} [provider] 
     * @param {string} [externalIdentifier] 
     * @param {string} [authData] 
     * @param {string} [emailNotifications] 
     * @param {string} [id] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Profiles} [profiles] profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesPatch(createdAt?: string, firstname?: string, lastname?: string, role?: string, accountId?: string, type?: string, firstName?: string, lastName?: string, email?: string, password?: string, location?: string, title?: string, description?: string, tags?: string, avatar?: string, language?: string, theme?: string, tfaSecret?: string, status?: string, token?: string, lastAccess?: string, lastPage?: string, provider?: string, externalIdentifier?: string, authData?: string, emailNotifications?: string, id?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: AxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesPatch(createdAt, firstname, lastname, role, accountId, type, firstName, lastName, email, password, location, title, description, tags, avatar, language, theme, tfaSecret, status, token, lastAccess, lastPage, provider, externalIdentifier, authData, emailNotifications, id, prefer, profiles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Profiles} [profiles] profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', profiles?: Profiles, options?: AxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesPost(select, prefer, profiles, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcAnonymousGetVideoDetailApi - axios parameter creator
 * @export
 */
export const RpcAnonymousGetVideoDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcAnonymousGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcAnonymousGetVideoDetailPost: async (args: RpcAnonymousGetVideoDetailPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcAnonymousGetVideoDetailPost', 'args', args)
            const localVarPath = `/rpc/anonymous_get_video_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcAnonymousGetVideoDetailApi - functional programming interface
 * @export
 */
export const RpcAnonymousGetVideoDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcAnonymousGetVideoDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcAnonymousGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcAnonymousGetVideoDetailPost(args: RpcAnonymousGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcAnonymousGetVideoDetailPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcAnonymousGetVideoDetailApi - factory interface
 * @export
 */
export const RpcAnonymousGetVideoDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcAnonymousGetVideoDetailApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcAnonymousGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcAnonymousGetVideoDetailPost(args: RpcAnonymousGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcAnonymousGetVideoDetailPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcAnonymousGetVideoDetailApi - object-oriented interface
 * @export
 * @class RpcAnonymousGetVideoDetailApi
 * @extends {BaseAPI}
 */
export class RpcAnonymousGetVideoDetailApi extends BaseAPI {
    /**
     * 
     * @param {RpcAnonymousGetVideoDetailPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcAnonymousGetVideoDetailApi
     */
    public rpcAnonymousGetVideoDetailPost(args: RpcAnonymousGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcAnonymousGetVideoDetailApiFp(this.configuration).rpcAnonymousGetVideoDetailPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcFollowersApi - axios parameter creator
 * @export
 */
export const RpcFollowersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcFollowersPost: async (args: RpcFollowersPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcFollowersPost', 'args', args)
            const localVarPath = `/rpc/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcFollowersApi - functional programming interface
 * @export
 */
export const RpcFollowersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcFollowersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcFollowersPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcFollowersPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcFollowersApi - factory interface
 * @export
 */
export const RpcFollowersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcFollowersApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcFollowersPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcFollowersPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcFollowersApi - object-oriented interface
 * @export
 * @class RpcFollowersApi
 * @extends {BaseAPI}
 */
export class RpcFollowersApi extends BaseAPI {
    /**
     * 
     * @param {RpcFollowersPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcFollowersApi
     */
    public rpcFollowersPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcFollowersApiFp(this.configuration).rpcFollowersPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcFollowingsApi - axios parameter creator
 * @export
 */
export const RpcFollowingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcFollowingsPost: async (args: RpcFollowersPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcFollowingsPost', 'args', args)
            const localVarPath = `/rpc/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcFollowingsApi - functional programming interface
 * @export
 */
export const RpcFollowingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcFollowingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcFollowingsPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcFollowingsPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcFollowingsApi - factory interface
 * @export
 */
export const RpcFollowingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcFollowingsApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcFollowingsPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcFollowingsPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcFollowingsApi - object-oriented interface
 * @export
 * @class RpcFollowingsApi
 * @extends {BaseAPI}
 */
export class RpcFollowingsApi extends BaseAPI {
    /**
     * 
     * @param {RpcFollowersPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcFollowingsApi
     */
    public rpcFollowingsPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcFollowingsApiFp(this.configuration).rpcFollowingsPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetAccountsCountApi - axios parameter creator
 * @export
 */
export const RpcGetAccountsCountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetAccountsCountPost: async (args: object, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetAccountsCountPost', 'args', args)
            const localVarPath = `/rpc/get_accounts_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetAccountsCountApi - functional programming interface
 * @export
 */
export const RpcGetAccountsCountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetAccountsCountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetAccountsCountPost(args: object, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetAccountsCountPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetAccountsCountApi - factory interface
 * @export
 */
export const RpcGetAccountsCountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetAccountsCountApiFp(configuration)
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetAccountsCountPost(args: object, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetAccountsCountPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetAccountsCountApi - object-oriented interface
 * @export
 * @class RpcGetAccountsCountApi
 * @extends {BaseAPI}
 */
export class RpcGetAccountsCountApi extends BaseAPI {
    /**
     * 
     * @param {object} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetAccountsCountApi
     */
    public rpcGetAccountsCountPost(args: object, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetAccountsCountApiFp(this.configuration).rpcGetAccountsCountPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetLastUpdatedApi - axios parameter creator
 * @export
 */
export const RpcGetLastUpdatedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcGetLastUpdatedPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetLastUpdatedPost: async (args: RpcGetLastUpdatedPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetLastUpdatedPost', 'args', args)
            const localVarPath = `/rpc/get_last_updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetLastUpdatedApi - functional programming interface
 * @export
 */
export const RpcGetLastUpdatedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetLastUpdatedApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcGetLastUpdatedPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetLastUpdatedPost(args: RpcGetLastUpdatedPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetLastUpdatedPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetLastUpdatedApi - factory interface
 * @export
 */
export const RpcGetLastUpdatedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetLastUpdatedApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcGetLastUpdatedPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetLastUpdatedPost(args: RpcGetLastUpdatedPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetLastUpdatedPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetLastUpdatedApi - object-oriented interface
 * @export
 * @class RpcGetLastUpdatedApi
 * @extends {BaseAPI}
 */
export class RpcGetLastUpdatedApi extends BaseAPI {
    /**
     * 
     * @param {RpcGetLastUpdatedPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetLastUpdatedApi
     */
    public rpcGetLastUpdatedPost(args: RpcGetLastUpdatedPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetLastUpdatedApiFp(this.configuration).rpcGetLastUpdatedPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetLastupdatedAccountApi - axios parameter creator
 * @export
 */
export const RpcGetLastupdatedAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetLastupdatedAccountPost: async (args: object, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetLastupdatedAccountPost', 'args', args)
            const localVarPath = `/rpc/get_lastupdated_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetLastupdatedAccountApi - functional programming interface
 * @export
 */
export const RpcGetLastupdatedAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetLastupdatedAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetLastupdatedAccountPost(args: object, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetLastupdatedAccountPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetLastupdatedAccountApi - factory interface
 * @export
 */
export const RpcGetLastupdatedAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetLastupdatedAccountApiFp(configuration)
    return {
        /**
         * 
         * @param {object} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetLastupdatedAccountPost(args: object, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetLastupdatedAccountPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetLastupdatedAccountApi - object-oriented interface
 * @export
 * @class RpcGetLastupdatedAccountApi
 * @extends {BaseAPI}
 */
export class RpcGetLastupdatedAccountApi extends BaseAPI {
    /**
     * 
     * @param {object} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetLastupdatedAccountApi
     */
    public rpcGetLastupdatedAccountPost(args: object, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetLastupdatedAccountApiFp(this.configuration).rpcGetLastupdatedAccountPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetSupabaseTagsApi - axios parameter creator
 * @export
 */
export const RpcGetSupabaseTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetSupabaseTagsPost: async (args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetSupabaseTagsPost', 'args', args)
            const localVarPath = `/rpc/get_supabase_tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetSupabaseTagsApi - functional programming interface
 * @export
 */
export const RpcGetSupabaseTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetSupabaseTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetSupabaseTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetSupabaseTagsPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetSupabaseTagsApi - factory interface
 * @export
 */
export const RpcGetSupabaseTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetSupabaseTagsApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetSupabaseTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetSupabaseTagsPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetSupabaseTagsApi - object-oriented interface
 * @export
 * @class RpcGetSupabaseTagsApi
 * @extends {BaseAPI}
 */
export class RpcGetSupabaseTagsApi extends BaseAPI {
    /**
     * 
     * @param {RpcGetSupabaseTagsPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetSupabaseTagsApi
     */
    public rpcGetSupabaseTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetSupabaseTagsApiFp(this.configuration).rpcGetSupabaseTagsPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetTagsApi - axios parameter creator
 * @export
 */
export const RpcGetTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetTagsPost: async (args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetTagsPost', 'args', args)
            const localVarPath = `/rpc/get_tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetTagsApi - functional programming interface
 * @export
 */
export const RpcGetTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetTagsPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetTagsApi - factory interface
 * @export
 */
export const RpcGetTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetTagsApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcGetSupabaseTagsPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetTagsPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetTagsApi - object-oriented interface
 * @export
 * @class RpcGetTagsApi
 * @extends {BaseAPI}
 */
export class RpcGetTagsApi extends BaseAPI {
    /**
     * 
     * @param {RpcGetSupabaseTagsPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetTagsApi
     */
    public rpcGetTagsPost(args: RpcGetSupabaseTagsPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetTagsApiFp(this.configuration).rpcGetTagsPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcGetVideoDetailApi - axios parameter creator
 * @export
 */
export const RpcGetVideoDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetVideoDetailPost: async (args: RpcGetVideoDetailPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcGetVideoDetailPost', 'args', args)
            const localVarPath = `/rpc/get_video_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcGetVideoDetailApi - functional programming interface
 * @export
 */
export const RpcGetVideoDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcGetVideoDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcGetVideoDetailPost(args: RpcGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcGetVideoDetailPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcGetVideoDetailApi - factory interface
 * @export
 */
export const RpcGetVideoDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcGetVideoDetailApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcGetVideoDetailPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcGetVideoDetailPost(args: RpcGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcGetVideoDetailPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcGetVideoDetailApi - object-oriented interface
 * @export
 * @class RpcGetVideoDetailApi
 * @extends {BaseAPI}
 */
export class RpcGetVideoDetailApi extends BaseAPI {
    /**
     * 
     * @param {RpcGetVideoDetailPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcGetVideoDetailApi
     */
    public rpcGetVideoDetailPost(args: RpcGetVideoDetailPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcGetVideoDetailApiFp(this.configuration).rpcGetVideoDetailPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcNearbyVideosApi - axios parameter creator
 * @export
 */
export const RpcNearbyVideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcNearbyVideosPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcNearbyVideosPost: async (args: RpcNearbyVideosPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcNearbyVideosPost', 'args', args)
            const localVarPath = `/rpc/nearby_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcNearbyVideosApi - functional programming interface
 * @export
 */
export const RpcNearbyVideosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcNearbyVideosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcNearbyVideosPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcNearbyVideosPost(args: RpcNearbyVideosPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcNearbyVideosPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcNearbyVideosApi - factory interface
 * @export
 */
export const RpcNearbyVideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcNearbyVideosApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcNearbyVideosPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcNearbyVideosPost(args: RpcNearbyVideosPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcNearbyVideosPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcNearbyVideosApi - object-oriented interface
 * @export
 * @class RpcNearbyVideosApi
 * @extends {BaseAPI}
 */
export class RpcNearbyVideosApi extends BaseAPI {
    /**
     * 
     * @param {RpcNearbyVideosPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcNearbyVideosApi
     */
    public rpcNearbyVideosPost(args: RpcNearbyVideosPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcNearbyVideosApiFp(this.configuration).rpcNearbyVideosPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcProfileDetailApi - axios parameter creator
 * @export
 */
export const RpcProfileDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcProfileDetailPost: async (args: RpcFollowersPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcProfileDetailPost', 'args', args)
            const localVarPath = `/rpc/profile_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcProfileDetailApi - functional programming interface
 * @export
 */
export const RpcProfileDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcProfileDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcProfileDetailPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcProfileDetailPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcProfileDetailApi - factory interface
 * @export
 */
export const RpcProfileDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcProfileDetailApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcFollowersPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcProfileDetailPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcProfileDetailPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcProfileDetailApi - object-oriented interface
 * @export
 * @class RpcProfileDetailApi
 * @extends {BaseAPI}
 */
export class RpcProfileDetailApi extends BaseAPI {
    /**
     * 
     * @param {RpcFollowersPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcProfileDetailApi
     */
    public rpcProfileDetailPost(args: RpcFollowersPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcProfileDetailApiFp(this.configuration).rpcProfileDetailPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RpcVideosInBoudingBoxApi - axios parameter creator
 * @export
 */
export const RpcVideosInBoudingBoxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RpcVideosInBoudingBoxPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcVideosInBoudingBoxPost: async (args: RpcVideosInBoudingBoxPostRequest, prefer?: 'params=single-object', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'args' is not null or undefined
            assertParamExists('rpcVideosInBoudingBoxPost', 'args', args)
            const localVarPath = `/rpc/videos_in_bouding_box`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(args, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcVideosInBoudingBoxApi - functional programming interface
 * @export
 */
export const RpcVideosInBoudingBoxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpcVideosInBoudingBoxApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RpcVideosInBoudingBoxPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpcVideosInBoudingBoxPost(args: RpcVideosInBoudingBoxPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpcVideosInBoudingBoxPost(args, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpcVideosInBoudingBoxApi - factory interface
 * @export
 */
export const RpcVideosInBoudingBoxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpcVideosInBoudingBoxApiFp(configuration)
    return {
        /**
         * 
         * @param {RpcVideosInBoudingBoxPostRequest} args 
         * @param {'params=single-object'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcVideosInBoudingBoxPost(args: RpcVideosInBoudingBoxPostRequest, prefer?: 'params=single-object', options?: any): AxiosPromise<void> {
            return localVarFp.rpcVideosInBoudingBoxPost(args, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpcVideosInBoudingBoxApi - object-oriented interface
 * @export
 * @class RpcVideosInBoudingBoxApi
 * @extends {BaseAPI}
 */
export class RpcVideosInBoudingBoxApi extends BaseAPI {
    /**
     * 
     * @param {RpcVideosInBoudingBoxPostRequest} args 
     * @param {'params=single-object'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcVideosInBoudingBoxApi
     */
    public rpcVideosInBoudingBoxPost(args: RpcVideosInBoudingBoxPostRequest, prefer?: 'params=single-object', options?: AxiosRequestConfig) {
        return RpcVideosInBoudingBoxApiFp(this.configuration).rpcVideosInBoudingBoxPost(args, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SdrsApi - axios parameter creator
 * @export
 */
export const SdrsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsDelete: async (id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdrs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (partnerName !== undefined) {
                localVarQueryParameter['partnerName'] = partnerName;
            }

            if (staffMember !== undefined) {
                localVarQueryParameter['staffMember'] = staffMember;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (disposition !== undefined) {
                localVarQueryParameter['disposition'] = disposition;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsGet: async (id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdrs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (partnerName !== undefined) {
                localVarQueryParameter['partnerName'] = partnerName;
            }

            if (staffMember !== undefined) {
                localVarQueryParameter['staffMember'] = staffMember;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (disposition !== undefined) {
                localVarQueryParameter['disposition'] = disposition;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsPatch: async (id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdrs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partnerNumber'] = partnerNumber;
            }

            if (partnerName !== undefined) {
                localVarQueryParameter['partnerName'] = partnerName;
            }

            if (staffMember !== undefined) {
                localVarQueryParameter['staffMember'] = staffMember;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (disposition !== undefined) {
                localVarQueryParameter['disposition'] = disposition;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sdrs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdrs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sdrs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdrsApi - functional programming interface
 * @export
 */
export const SdrsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdrsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sdrsDelete(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sdrsDelete(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sdrsGet(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sdrs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sdrsGet(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sdrsPatch(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sdrsPatch(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, sdrs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sdrsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sdrsPost(select, prefer, sdrs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SdrsApi - factory interface
 * @export
 */
export const SdrsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdrsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsDelete(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.sdrsDelete(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsGet(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Sdrs>> {
            return localVarFp.sdrsGet(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [partnerNumber] 
         * @param {string} [partnerName] 
         * @param {string} [staffMember] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number} [duration] 
         * @param {string} [direction] 
         * @param {string} [disposition] 
         * @param {string} [createdAt] 
         * @param {string} [userId] 
         * @param {string} [accountId] 
         * @param {string} [updatedAt] 
         * @param {string} [transcription] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsPatch(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: any): AxiosPromise<void> {
            return localVarFp.sdrsPatch(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, sdrs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sdrs} [sdrs] sdrs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sdrsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: any): AxiosPromise<void> {
            return localVarFp.sdrsPost(select, prefer, sdrs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdrsApi - object-oriented interface
 * @export
 * @class SdrsApi
 * @extends {BaseAPI}
 */
export class SdrsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [partnerNumber] 
     * @param {string} [partnerName] 
     * @param {string} [staffMember] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {number} [duration] 
     * @param {string} [direction] 
     * @param {string} [disposition] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [accountId] 
     * @param {string} [updatedAt] 
     * @param {string} [transcription] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdrsApi
     */
    public sdrsDelete(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return SdrsApiFp(this.configuration).sdrsDelete(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [partnerNumber] 
     * @param {string} [partnerName] 
     * @param {string} [staffMember] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {number} [duration] 
     * @param {string} [direction] 
     * @param {string} [disposition] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [accountId] 
     * @param {string} [updatedAt] 
     * @param {string} [transcription] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdrsApi
     */
    public sdrsGet(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return SdrsApiFp(this.configuration).sdrsGet(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [partnerNumber] 
     * @param {string} [partnerName] 
     * @param {string} [staffMember] 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {number} [duration] 
     * @param {string} [direction] 
     * @param {string} [disposition] 
     * @param {string} [createdAt] 
     * @param {string} [userId] 
     * @param {string} [accountId] 
     * @param {string} [updatedAt] 
     * @param {string} [transcription] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Sdrs} [sdrs] sdrs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdrsApi
     */
    public sdrsPatch(id?: string, partnerNumber?: string, partnerName?: string, staffMember?: string, start?: string, end?: string, duration?: number, direction?: string, disposition?: string, createdAt?: string, userId?: string, accountId?: string, updatedAt?: string, transcription?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: AxiosRequestConfig) {
        return SdrsApiFp(this.configuration).sdrsPatch(id, partnerNumber, partnerName, staffMember, start, end, duration, direction, disposition, createdAt, userId, accountId, updatedAt, transcription, prefer, sdrs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Sdrs} [sdrs] sdrs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdrsApi
     */
    public sdrsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sdrs?: Sdrs, options?: AxiosRequestConfig) {
        return SdrsApiFp(this.configuration).sdrsPost(select, prefer, sdrs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SitesApi - axios parameter creator
 * @export
 */
export const SitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDelete: async (accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (street !== undefined) {
                localVarQueryParameter['street'] = street;
            }

            if (street2 !== undefined) {
                localVarQueryParameter['street2'] = street2;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (county !== undefined) {
                localVarQueryParameter['county'] = county;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (primaryContactID !== undefined) {
                localVarQueryParameter['primaryContactID'] = primaryContactID;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (zip !== undefined) {
                localVarQueryParameter['zip'] = zip;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGet: async (accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (street !== undefined) {
                localVarQueryParameter['street'] = street;
            }

            if (street2 !== undefined) {
                localVarQueryParameter['street2'] = street2;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (county !== undefined) {
                localVarQueryParameter['county'] = county;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (primaryContactID !== undefined) {
                localVarQueryParameter['primaryContactID'] = primaryContactID;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (zip !== undefined) {
                localVarQueryParameter['zip'] = zip;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPatch: async (accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (street !== undefined) {
                localVarQueryParameter['street'] = street;
            }

            if (street2 !== undefined) {
                localVarQueryParameter['street2'] = street2;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (note !== undefined) {
                localVarQueryParameter['note'] = note;
            }

            if (county !== undefined) {
                localVarQueryParameter['county'] = county;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (primaryContactID !== undefined) {
                localVarQueryParameter['primaryContactID'] = primaryContactID;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (taxExempt !== undefined) {
                localVarQueryParameter['taxExempt'] = taxExempt;
            }

            if (taxID !== undefined) {
                localVarQueryParameter['taxID'] = taxID;
            }

            if (createdById !== undefined) {
                localVarQueryParameter['createdById'] = createdById;
            }

            if (zip !== undefined) {
                localVarQueryParameter['zip'] = zip;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sites, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sites, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDelete(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDelete(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGet(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sites>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGet(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPatch(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPatch(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, sites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPost(select, prefer, sites, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDelete(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.sitesDelete(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGet(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Sites>> {
            return localVarFp.sitesGet(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [accountId] 
         * @param {string} [createdAt] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {boolean} [active] 
         * @param {string} [street] 
         * @param {string} [street2] 
         * @param {string} [city] 
         * @param {string} [country] 
         * @param {string} [note] 
         * @param {string} [county] 
         * @param {boolean} [isDefault] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [name] 
         * @param {string} [primaryContactID] 
         * @param {string} [state] 
         * @param {boolean} [taxExempt] 
         * @param {string} [taxID] 
         * @param {string} [createdById] 
         * @param {string} [zip] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPatch(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: any): AxiosPromise<void> {
            return localVarFp.sitesPatch(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, sites, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Sites} [sites] sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: any): AxiosPromise<void> {
            return localVarFp.sitesPost(select, prefer, sites, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [street] 
     * @param {string} [street2] 
     * @param {string} [city] 
     * @param {string} [country] 
     * @param {string} [note] 
     * @param {string} [county] 
     * @param {boolean} [isDefault] 
     * @param {string} [latitude] 
     * @param {string} [longitude] 
     * @param {string} [name] 
     * @param {string} [primaryContactID] 
     * @param {string} [state] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [createdById] 
     * @param {string} [zip] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesDelete(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).sitesDelete(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [street] 
     * @param {string} [street2] 
     * @param {string} [city] 
     * @param {string} [country] 
     * @param {string} [note] 
     * @param {string} [county] 
     * @param {boolean} [isDefault] 
     * @param {string} [latitude] 
     * @param {string} [longitude] 
     * @param {string} [name] 
     * @param {string} [primaryContactID] 
     * @param {string} [state] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [createdById] 
     * @param {string} [zip] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesGet(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).sitesGet(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [accountId] 
     * @param {string} [createdAt] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {boolean} [active] 
     * @param {string} [street] 
     * @param {string} [street2] 
     * @param {string} [city] 
     * @param {string} [country] 
     * @param {string} [note] 
     * @param {string} [county] 
     * @param {boolean} [isDefault] 
     * @param {string} [latitude] 
     * @param {string} [longitude] 
     * @param {string} [name] 
     * @param {string} [primaryContactID] 
     * @param {string} [state] 
     * @param {boolean} [taxExempt] 
     * @param {string} [taxID] 
     * @param {string} [createdById] 
     * @param {string} [zip] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Sites} [sites] sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesPatch(accountId?: string, createdAt?: string, id?: string, updatedAt?: string, active?: boolean, street?: string, street2?: string, city?: string, country?: string, note?: string, county?: string, isDefault?: boolean, latitude?: string, longitude?: string, name?: string, primaryContactID?: string, state?: string, taxExempt?: boolean, taxID?: string, createdById?: string, zip?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).sitesPatch(accountId, createdAt, id, updatedAt, active, street, street2, city, country, note, county, isDefault, latitude, longitude, name, primaryContactID, state, taxExempt, taxID, createdById, zip, prefer, sites, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Sites} [sites] sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', sites?: Sites, options?: AxiosRequestConfig) {
        return SitesApiFp(this.configuration).sitesPost(select, prefer, sites, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageUnitTypesApi - axios parameter creator
 * @export
 */
export const StorageUnitTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesDelete: async (id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_unit_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (totalSf !== undefined) {
                localVarQueryParameter['totalSf'] = totalSf;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (storeprice !== undefined) {
                localVarQueryParameter['storeprice'] = storeprice;
            }

            if (internetdiscount !== undefined) {
                localVarQueryParameter['internetdiscount'] = internetdiscount;
            }

            if (totalUnits !== undefined) {
                localVarQueryParameter['total_units'] = totalUnits;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesGet: async (id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_unit_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (totalSf !== undefined) {
                localVarQueryParameter['totalSf'] = totalSf;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (storeprice !== undefined) {
                localVarQueryParameter['storeprice'] = storeprice;
            }

            if (internetdiscount !== undefined) {
                localVarQueryParameter['internetdiscount'] = internetdiscount;
            }

            if (totalUnits !== undefined) {
                localVarQueryParameter['total_units'] = totalUnits;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesPatch: async (id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_unit_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (totalSf !== undefined) {
                localVarQueryParameter['totalSf'] = totalSf;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (storeprice !== undefined) {
                localVarQueryParameter['storeprice'] = storeprice;
            }

            if (internetdiscount !== undefined) {
                localVarQueryParameter['internetdiscount'] = internetdiscount;
            }

            if (totalUnits !== undefined) {
                localVarQueryParameter['total_units'] = totalUnits;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageUnitTypes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_unit_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageUnitTypes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageUnitTypesApi - functional programming interface
 * @export
 */
export const StorageUnitTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageUnitTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitTypesDelete(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitTypesDelete(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitTypesGet(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageUnitTypes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitTypesGet(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitTypesPatch(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitTypesPatch(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, storageUnitTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitTypesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitTypesPost(select, prefer, storageUnitTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageUnitTypesApi - factory interface
 * @export
 */
export const StorageUnitTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageUnitTypesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesDelete(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitTypesDelete(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesGet(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<StorageUnitTypes>> {
            return localVarFp.storageUnitTypesGet(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [totalSf] 
         * @param {string} [label] 
         * @param {string} [features] 
         * @param {string} [image] 
         * @param {string} [storeprice] 
         * @param {number} [internetdiscount] 
         * @param {number} [totalUnits] 
         * @param {string} [category] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesPatch(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitTypesPatch(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, storageUnitTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitTypesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitTypesPost(select, prefer, storageUnitTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageUnitTypesApi - object-oriented interface
 * @export
 * @class StorageUnitTypesApi
 * @extends {BaseAPI}
 */
export class StorageUnitTypesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [totalSf] 
     * @param {string} [label] 
     * @param {string} [features] 
     * @param {string} [image] 
     * @param {string} [storeprice] 
     * @param {number} [internetdiscount] 
     * @param {number} [totalUnits] 
     * @param {string} [category] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitTypesApi
     */
    public storageUnitTypesDelete(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return StorageUnitTypesApiFp(this.configuration).storageUnitTypesDelete(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [totalSf] 
     * @param {string} [label] 
     * @param {string} [features] 
     * @param {string} [image] 
     * @param {string} [storeprice] 
     * @param {number} [internetdiscount] 
     * @param {number} [totalUnits] 
     * @param {string} [category] 
     * @param {string} [updatedAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitTypesApi
     */
    public storageUnitTypesGet(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return StorageUnitTypesApiFp(this.configuration).storageUnitTypesGet(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [totalSf] 
     * @param {string} [label] 
     * @param {string} [features] 
     * @param {string} [image] 
     * @param {string} [storeprice] 
     * @param {number} [internetdiscount] 
     * @param {number} [totalUnits] 
     * @param {string} [category] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitTypesApi
     */
    public storageUnitTypesPatch(id?: string, createdAt?: string, totalSf?: string, label?: string, features?: string, image?: string, storeprice?: string, internetdiscount?: number, totalUnits?: number, category?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: AxiosRequestConfig) {
        return StorageUnitTypesApiFp(this.configuration).storageUnitTypesPatch(id, createdAt, totalSf, label, features, image, storeprice, internetdiscount, totalUnits, category, updatedAt, prefer, storageUnitTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {StorageUnitTypes} [storageUnitTypes] storage_unit_types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitTypesApi
     */
    public storageUnitTypesPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnitTypes?: StorageUnitTypes, options?: AxiosRequestConfig) {
        return StorageUnitTypesApiFp(this.configuration).storageUnitTypesPost(select, prefer, storageUnitTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageUnitsApi - axios parameter creator
 * @export
 */
export const StorageUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsDelete: async (createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['typeId'] = typeId;
            }

            if (available !== undefined) {
                localVarQueryParameter['available'] = available;
            }

            if (building !== undefined) {
                localVarQueryParameter['building'] = building;
            }

            if (unitNumber !== undefined) {
                localVarQueryParameter['unit_number'] = unitNumber;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsGet: async (createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['typeId'] = typeId;
            }

            if (available !== undefined) {
                localVarQueryParameter['available'] = available;
            }

            if (building !== undefined) {
                localVarQueryParameter['building'] = building;
            }

            if (unitNumber !== undefined) {
                localVarQueryParameter['unit_number'] = unitNumber;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsPatch: async (createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['typeId'] = typeId;
            }

            if (available !== undefined) {
                localVarQueryParameter['available'] = available;
            }

            if (building !== undefined) {
                localVarQueryParameter['building'] = building;
            }

            if (unitNumber !== undefined) {
                localVarQueryParameter['unit_number'] = unitNumber;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageUnits, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage_units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageUnits, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageUnitsApi - functional programming interface
 * @export
 */
export const StorageUnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageUnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitsDelete(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitsDelete(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitsGet(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageUnits>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitsGet(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitsPatch(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitsPatch(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, storageUnits, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageUnitsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageUnitsPost(select, prefer, storageUnits, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageUnitsApi - factory interface
 * @export
 */
export const StorageUnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageUnitsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsDelete(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitsDelete(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsGet(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<StorageUnits>> {
            return localVarFp.storageUnitsGet(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [typeId] 
         * @param {boolean} [available] 
         * @param {string} [building] 
         * @param {string} [unitNumber] 
         * @param {string} [tenantId] 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsPatch(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitsPatch(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, storageUnits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {StorageUnits} [storageUnits] storage_units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageUnitsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: any): AxiosPromise<void> {
            return localVarFp.storageUnitsPost(select, prefer, storageUnits, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageUnitsApi - object-oriented interface
 * @export
 * @class StorageUnitsApi
 * @extends {BaseAPI}
 */
export class StorageUnitsApi extends BaseAPI {
    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [typeId] 
     * @param {boolean} [available] 
     * @param {string} [building] 
     * @param {string} [unitNumber] 
     * @param {string} [tenantId] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitsApi
     */
    public storageUnitsDelete(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return StorageUnitsApiFp(this.configuration).storageUnitsDelete(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [typeId] 
     * @param {boolean} [available] 
     * @param {string} [building] 
     * @param {string} [unitNumber] 
     * @param {string} [tenantId] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitsApi
     */
    public storageUnitsGet(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return StorageUnitsApiFp(this.configuration).storageUnitsGet(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAt] 
     * @param {string} [typeId] 
     * @param {boolean} [available] 
     * @param {string} [building] 
     * @param {string} [unitNumber] 
     * @param {string} [tenantId] 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {StorageUnits} [storageUnits] storage_units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitsApi
     */
    public storageUnitsPatch(createdAt?: string, typeId?: string, available?: boolean, building?: string, unitNumber?: string, tenantId?: string, id?: string, updatedAt?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: AxiosRequestConfig) {
        return StorageUnitsApiFp(this.configuration).storageUnitsPatch(createdAt, typeId, available, building, unitNumber, tenantId, id, updatedAt, prefer, storageUnits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {StorageUnits} [storageUnits] storage_units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageUnitsApi
     */
    public storageUnitsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', storageUnits?: StorageUnits, options?: AxiosRequestConfig) {
        return StorageUnitsApiFp(this.configuration).storageUnitsPost(select, prefer, storageUnits, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TableCountsApi - axios parameter creator
 * @export
 */
export const TableCountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [schemaname] 
         * @param {string} [relname] 
         * @param {string} [reltuples] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableCountsGet: async (schemaname?: string, relname?: string, reltuples?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/table_counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (schemaname !== undefined) {
                localVarQueryParameter['schemaname'] = schemaname;
            }

            if (relname !== undefined) {
                localVarQueryParameter['relname'] = relname;
            }

            if (reltuples !== undefined) {
                localVarQueryParameter['reltuples'] = reltuples;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TableCountsApi - functional programming interface
 * @export
 */
export const TableCountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TableCountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [schemaname] 
         * @param {string} [relname] 
         * @param {string} [reltuples] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tableCountsGet(schemaname?: string, relname?: string, reltuples?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TableCounts>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tableCountsGet(schemaname, relname, reltuples, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TableCountsApi - factory interface
 * @export
 */
export const TableCountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TableCountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [schemaname] 
         * @param {string} [relname] 
         * @param {string} [reltuples] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableCountsGet(schemaname?: string, relname?: string, reltuples?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<TableCounts>> {
            return localVarFp.tableCountsGet(schemaname, relname, reltuples, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TableCountsApi - object-oriented interface
 * @export
 * @class TableCountsApi
 * @extends {BaseAPI}
 */
export class TableCountsApi extends BaseAPI {
    /**
     * 
     * @param {string} [schemaname] 
     * @param {string} [relname] 
     * @param {string} [reltuples] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TableCountsApi
     */
    public tableCountsGet(schemaname?: string, relname?: string, reltuples?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return TableCountsApiFp(this.configuration).tableCountsGet(schemaname, relname, reltuples, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsViewApi - axios parameter creator
 * @export
 */
export const TagsViewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {string} [count] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsViewGet: async (tags?: string, count?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags_view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsViewApi - functional programming interface
 * @export
 */
export const TagsViewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsViewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {string} [count] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsViewGet(tags?: string, count?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagsView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsViewGet(tags, count, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsViewApi - factory interface
 * @export
 */
export const TagsViewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsViewApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [tags] 
         * @param {string} [count] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsViewGet(tags?: string, count?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<TagsView>> {
            return localVarFp.tagsViewGet(tags, count, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsViewApi - object-oriented interface
 * @export
 * @class TagsViewApi
 * @extends {BaseAPI}
 */
export class TagsViewApi extends BaseAPI {
    /**
     * 
     * @param {string} [tags] 
     * @param {string} [count] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsViewApi
     */
    public tagsViewGet(tags?: string, count?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return TagsViewApiFp(this.configuration).tagsViewGet(tags, count, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimelogsApi - axios parameter creator
 * @export
 */
export const TimelogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsDelete: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timelogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsGet: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timelogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsPatch: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timelogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timelogs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timelogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timelogs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimelogsApi - functional programming interface
 * @export
 */
export const TimelogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimelogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timelogsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timelogsDelete(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timelogsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Timelogs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timelogsGet(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timelogsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timelogsPatch(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, timelogs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timelogsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timelogsPost(select, prefer, timelogs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimelogsApi - factory interface
 * @export
 */
export const TimelogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimelogsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.timelogsDelete(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Timelogs>> {
            return localVarFp.timelogsGet(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [timesheetId] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: any): AxiosPromise<void> {
            return localVarFp.timelogsPatch(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, timelogs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timelogs} [timelogs] timelogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timelogsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: any): AxiosPromise<void> {
            return localVarFp.timelogsPost(select, prefer, timelogs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimelogsApi - object-oriented interface
 * @export
 * @class TimelogsApi
 * @extends {BaseAPI}
 */
export class TimelogsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [timesheetId] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelogsApi
     */
    public timelogsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return TimelogsApiFp(this.configuration).timelogsDelete(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [timesheetId] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelogsApi
     */
    public timelogsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return TimelogsApiFp(this.configuration).timelogsGet(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [timesheetId] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Timelogs} [timelogs] timelogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelogsApi
     */
    public timelogsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, timesheetId?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: AxiosRequestConfig) {
        return TimelogsApiFp(this.configuration).timelogsPatch(id, createdAt, updatedAt, startedAt, endedAt, timesheetId, employeeId, approved, approvedBy, image, prefer, timelogs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Timelogs} [timelogs] timelogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimelogsApi
     */
    public timelogsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timelogs?: Timelogs, options?: AxiosRequestConfig) {
        return TimelogsApiFp(this.configuration).timelogsPost(select, prefer, timelogs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimesheetsApi - axios parameter creator
 * @export
 */
export const TimesheetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsDelete: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timesheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (timelogs !== undefined) {
                localVarQueryParameter['timelogs'] = timelogs;
            }

            if (timelogsCount !== undefined) {
                localVarQueryParameter['timelogsCount'] = timelogsCount;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsGet: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timesheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (timelogs !== undefined) {
                localVarQueryParameter['timelogs'] = timelogs;
            }

            if (timelogsCount !== undefined) {
                localVarQueryParameter['timelogsCount'] = timelogsCount;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsPatch: async (id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timesheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (startedAt !== undefined) {
                localVarQueryParameter['startedAt'] = startedAt;
            }

            if (endedAt !== undefined) {
                localVarQueryParameter['endedAt'] = endedAt;
            }

            if (employeeId !== undefined) {
                localVarQueryParameter['employeeId'] = employeeId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (approvedBy !== undefined) {
                localVarQueryParameter['approvedBy'] = approvedBy;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (timelogs !== undefined) {
                localVarQueryParameter['timelogs'] = timelogs;
            }

            if (timelogsCount !== undefined) {
                localVarQueryParameter['timelogsCount'] = timelogsCount;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timesheets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timesheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timesheets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheetsApi - functional programming interface
 * @export
 */
export const TimesheetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimesheetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timesheetsDelete(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Timesheets>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timesheetsGet(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timesheetsPatch(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, timesheets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timesheetsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timesheetsPost(select, prefer, timesheets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimesheetsApi - factory interface
 * @export
 */
export const TimesheetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimesheetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.timesheetsDelete(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Timesheets>> {
            return localVarFp.timesheetsGet(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [updatedAt] 
         * @param {string} [startedAt] 
         * @param {string} [endedAt] 
         * @param {string} [employeeId] 
         * @param {boolean} [approved] 
         * @param {string} [approvedBy] 
         * @param {string} [image] 
         * @param {string} [timelogs] 
         * @param {number} [timelogsCount] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: any): AxiosPromise<void> {
            return localVarFp.timesheetsPatch(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, timesheets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Timesheets} [timesheets] timesheets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timesheetsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: any): AxiosPromise<void> {
            return localVarFp.timesheetsPost(select, prefer, timesheets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimesheetsApi - object-oriented interface
 * @export
 * @class TimesheetsApi
 * @extends {BaseAPI}
 */
export class TimesheetsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {string} [timelogs] 
     * @param {number} [timelogsCount] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsDelete(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).timesheetsDelete(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {string} [timelogs] 
     * @param {number} [timelogsCount] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsGet(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).timesheetsGet(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [updatedAt] 
     * @param {string} [startedAt] 
     * @param {string} [endedAt] 
     * @param {string} [employeeId] 
     * @param {boolean} [approved] 
     * @param {string} [approvedBy] 
     * @param {string} [image] 
     * @param {string} [timelogs] 
     * @param {number} [timelogsCount] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Timesheets} [timesheets] timesheets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsPatch(id?: string, createdAt?: string, updatedAt?: string, startedAt?: string, endedAt?: string, employeeId?: string, approved?: boolean, approvedBy?: string, image?: string, timelogs?: string, timelogsCount?: number, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).timesheetsPatch(id, createdAt, updatedAt, startedAt, endedAt, employeeId, approved, approvedBy, image, timelogs, timelogsCount, prefer, timesheets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Timesheets} [timesheets] timesheets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApi
     */
    public timesheetsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', timesheets?: Timesheets, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).timesheetsPost(select, prefer, timesheets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TranscriptionsApi - axios parameter creator
 * @export
 */
export const TranscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsDelete: async (id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partner_number'] = partnerNumber;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsGet: async (id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partner_number'] = partnerNumber;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsPatch: async (id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (caller !== undefined) {
                localVarQueryParameter['caller'] = caller;
            }

            if (callee !== undefined) {
                localVarQueryParameter['callee'] = callee;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (transcription !== undefined) {
                localVarQueryParameter['transcription'] = transcription;
            }

            if (audioLocation !== undefined) {
                localVarQueryParameter['audio_location'] = audioLocation;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (partnerNumber !== undefined) {
                localVarQueryParameter['partner_number'] = partnerNumber;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranscriptionsApi - functional programming interface
 * @export
 */
export const TranscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TranscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptionsDelete(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcriptionsDelete(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptionsGet(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transcriptions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcriptionsGet(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptionsPatch(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcriptionsPatch(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, transcriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcriptionsPost(select, prefer, transcriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TranscriptionsApi - factory interface
 * @export
 */
export const TranscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TranscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsDelete(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.transcriptionsDelete(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsGet(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Transcriptions>> {
            return localVarFp.transcriptionsGet(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [caller] 
         * @param {string} [callee] 
         * @param {string} [direction] 
         * @param {string} [accountId] 
         * @param {string} [transcription] 
         * @param {string} [audioLocation] 
         * @param {string} [createdAt] 
         * @param {string} [partnerNumber] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsPatch(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: any): AxiosPromise<void> {
            return localVarFp.transcriptionsPatch(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, transcriptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Transcriptions} [transcriptions] transcriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: any): AxiosPromise<void> {
            return localVarFp.transcriptionsPost(select, prefer, transcriptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TranscriptionsApi - object-oriented interface
 * @export
 * @class TranscriptionsApi
 * @extends {BaseAPI}
 */
export class TranscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [direction] 
     * @param {string} [accountId] 
     * @param {string} [transcription] 
     * @param {string} [audioLocation] 
     * @param {string} [createdAt] 
     * @param {string} [partnerNumber] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptionsApi
     */
    public transcriptionsDelete(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return TranscriptionsApiFp(this.configuration).transcriptionsDelete(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [direction] 
     * @param {string} [accountId] 
     * @param {string} [transcription] 
     * @param {string} [audioLocation] 
     * @param {string} [createdAt] 
     * @param {string} [partnerNumber] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptionsApi
     */
    public transcriptionsGet(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return TranscriptionsApiFp(this.configuration).transcriptionsGet(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [caller] 
     * @param {string} [callee] 
     * @param {string} [direction] 
     * @param {string} [accountId] 
     * @param {string} [transcription] 
     * @param {string} [audioLocation] 
     * @param {string} [createdAt] 
     * @param {string} [partnerNumber] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Transcriptions} [transcriptions] transcriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptionsApi
     */
    public transcriptionsPatch(id?: string, updatedAt?: string, caller?: string, callee?: string, direction?: string, accountId?: string, transcription?: string, audioLocation?: string, createdAt?: string, partnerNumber?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: AxiosRequestConfig) {
        return TranscriptionsApiFp(this.configuration).transcriptionsPatch(id, updatedAt, caller, callee, direction, accountId, transcription, audioLocation, createdAt, partnerNumber, prefer, transcriptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Transcriptions} [transcriptions] transcriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranscriptionsApi
     */
    public transcriptionsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', transcriptions?: Transcriptions, options?: AxiosRequestConfig) {
        return TranscriptionsApiFp(this.configuration).transcriptionsPost(select, prefer, transcriptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewsApi - axios parameter creator
 * @export
 */
export const ViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsDelete: async (id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ip_address'] = ipAddress;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet: async (id?: string, createdAt?: string, ipAddress?: string, productId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ip_address'] = ipAddress;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPatch: async (id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ip_address'] = ipAddress;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(views, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/views`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(views, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewsDelete(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewsDelete(id, createdAt, ipAddress, productId, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewsGet(id?: string, createdAt?: string, ipAddress?: string, productId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Views>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewsGet(id, createdAt, ipAddress, productId, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewsPatch(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewsPatch(id, createdAt, ipAddress, productId, prefer, views, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewsPost(select, prefer, views, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsDelete(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.viewsDelete(id, createdAt, ipAddress, productId, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsGet(id?: string, createdAt?: string, ipAddress?: string, productId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<Views>> {
            return localVarFp.viewsGet(id, createdAt, ipAddress, productId, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ipAddress] 
         * @param {string} [productId] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPatch(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: any): AxiosPromise<void> {
            return localVarFp.viewsPatch(id, createdAt, ipAddress, productId, prefer, views, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {Views} [views] views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: any): AxiosPromise<void> {
            return localVarFp.viewsPost(select, prefer, views, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ipAddress] 
     * @param {string} [productId] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsDelete(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).viewsDelete(id, createdAt, ipAddress, productId, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ipAddress] 
     * @param {string} [productId] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsGet(id?: string, createdAt?: string, ipAddress?: string, productId?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).viewsGet(id, createdAt, ipAddress, productId, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ipAddress] 
     * @param {string} [productId] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Views} [views] views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsPatch(id?: string, createdAt?: string, ipAddress?: string, productId?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).viewsPatch(id, createdAt, ipAddress, productId, prefer, views, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {Views} [views] views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public viewsPost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', views?: Views, options?: AxiosRequestConfig) {
        return ViewsApiFp(this.configuration).viewsPost(select, prefer, views, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkOrderTypeApi - axios parameter creator
 * @export
 */
export const WorkOrderTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypeDelete: async (value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work_order_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypeGet: async (value?: string, comment?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work_order_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypePatch: async (value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work_order_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workOrderType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypePost: async (select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work_order_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workOrderType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkOrderTypeApi - functional programming interface
 * @export
 */
export const WorkOrderTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkOrderTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workOrderTypeDelete(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workOrderTypeDelete(value, comment, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workOrderTypeGet(value?: string, comment?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkOrderType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workOrderTypeGet(value, comment, select, order, range, rangeUnit, offset, limit, prefer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workOrderTypePatch(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workOrderTypePatch(value, comment, prefer, workOrderType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workOrderTypePost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workOrderTypePost(select, prefer, workOrderType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkOrderTypeApi - factory interface
 * @export
 */
export const WorkOrderTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkOrderTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypeDelete(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: any): AxiosPromise<void> {
            return localVarFp.workOrderTypeDelete(value, comment, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {'count=none'} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypeGet(value?: string, comment?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: any): AxiosPromise<Array<WorkOrderType>> {
            return localVarFp.workOrderTypeGet(value, comment, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [value] 
         * @param {string} [comment] 
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypePatch(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: any): AxiosPromise<void> {
            return localVarFp.workOrderTypePatch(value, comment, prefer, workOrderType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [select] Filtering Columns
         * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
         * @param {WorkOrderType} [workOrderType] work_order_type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workOrderTypePost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: any): AxiosPromise<void> {
            return localVarFp.workOrderTypePost(select, prefer, workOrderType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkOrderTypeApi - object-oriented interface
 * @export
 * @class WorkOrderTypeApi
 * @extends {BaseAPI}
 */
export class WorkOrderTypeApi extends BaseAPI {
    /**
     * 
     * @param {string} [value] 
     * @param {string} [comment] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkOrderTypeApi
     */
    public workOrderTypeDelete(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', options?: AxiosRequestConfig) {
        return WorkOrderTypeApiFp(this.configuration).workOrderTypeDelete(value, comment, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [value] 
     * @param {string} [comment] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {'count=none'} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkOrderTypeApi
     */
    public workOrderTypeGet(value?: string, comment?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: 'count=none', options?: AxiosRequestConfig) {
        return WorkOrderTypeApiFp(this.configuration).workOrderTypeGet(value, comment, select, order, range, rangeUnit, offset, limit, prefer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [value] 
     * @param {string} [comment] 
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {WorkOrderType} [workOrderType] work_order_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkOrderTypeApi
     */
    public workOrderTypePatch(value?: string, comment?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: AxiosRequestConfig) {
        return WorkOrderTypeApiFp(this.configuration).workOrderTypePatch(value, comment, prefer, workOrderType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [select] Filtering Columns
     * @param {'return=representation' | 'return=minimal' | 'return=none'} [prefer] Preference
     * @param {WorkOrderType} [workOrderType] work_order_type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkOrderTypeApi
     */
    public workOrderTypePost(select?: string, prefer?: 'return=representation' | 'return=minimal' | 'return=none', workOrderType?: WorkOrderType, options?: AxiosRequestConfig) {
        return WorkOrderTypeApiFp(this.configuration).workOrderTypePost(select, prefer, workOrderType, options).then((request) => request(this.axios, this.basePath));
    }
}


